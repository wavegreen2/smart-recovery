import math
import random

# ==========================================================
# ‚öôÔ∏è CONFIGURATION
# ==========================================================
CONFIG = {
    "initial_bankroll": 500000.0,
    "unit_size": 5.0,
    "chip_size": 5.0,
    "side_preference": "PLAYER", 
    "virtual_win_trigger": 5, 
    "stop_after_consecutive_loss": 4,  
    "recovery_mode": "aggressive",
    "recovery_ratio": 5,
    "max_unit_cap": 1,
    "marty_mult": 2.0,
    "marty_steps_limit": 12,
    "fibo_mult": 1.0,
    "stop_loss_threshold": 75000.0,
    "show_hand_by_hand": False 
}

# ==========================================================
# üß¨ CORE FUNCTIONS
# ==========================================================

def get_fibo(n):
    if n <= 0: return 1
    if n == 1: return 1
    a, b = 1, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

def get_next_result(data_list, current_idx, is_random=False):
    if is_random:
        # Banker 50.68%, Player 49.32% (Standard Baccarat excluding Tie)
        return "B" if random.random() < 0.5068 else "P", current_idx + 1
    
    if current_idx < len(data_list):
        return data_list[current_idx], current_idx + 1
    return None, current_idx

def run_single_session(
    result_list, start_idx, target_profit, unit_size, initial_bankroll, is_virtual_session=False, is_manual=False, is_random=False
):
    safe_unit = max(unit_size, 0.1) 
    bankroll = initial_bankroll
    peak_bankroll = initial_bankroll
    max_bet_in_session = 0
    max_dd_in_session = 0
    
    state = "FLAT"
    mart_step = 0
    fibo_idx = 0
    consecutive_loss = 0 
    has_lost_since_peak = False
    current_idx = start_idx
    hand_count = 0

    while True:
        current_drawdown = peak_bankroll - bankroll
        if current_drawdown >= CONFIG["stop_loss_threshold"]:
            state, mart_step, fibo_idx = "FLAT", 0, 0

        # 1. Determine Raw Bet
        if state == "FLAT":
            if current_drawdown > 0 and has_lost_since_peak:
                raw_bet = math.ceil(current_drawdown / 4)
                raw_bet = max(raw_bet, safe_unit)
            else:
                raw_bet = safe_unit
        elif state == "MARTY":
            raw_bet = safe_unit * (CONFIG["marty_mult"] ** mart_step)
        elif state == "FIBO":
            raw_bet = get_fibo(fibo_idx) * CONFIG["fibo_mult"]

        # 2. Betting Constraints
        needed_to_recover = current_drawdown + safe_unit
        bet = min(raw_bet, needed_to_recover) if state != "FLAT" else raw_bet
        bet = math.ceil(bet / CONFIG["chip_size"]) * CONFIG["chip_size"]
        
        current_profit = bankroll - initial_bankroll
        remaining = target_profit - current_profit
        
        # --- FIX: Logic ‡πÑ‡∏°‡πâ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ---
        if bet > remaining and remaining > 0:
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö target ‡∏û‡∏≠‡∏î‡∏µ (‡∏õ‡∏±‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡∏≤‡∏° chip_size)
            required_bet = math.ceil(remaining / CONFIG["chip_size"]) * CONFIG["chip_size"]
            # ‡πÉ‡∏ä‡πâ CONFIG["unit_size"] ‡πÄ‡∏õ‡πá‡∏ô‡∏ê‡∏≤‡∏ô‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡πÅ‡∏ó‡∏ô safe_unit ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏•‡∏á‡πÄ‡∏ö‡∏≤‡πÑ‡∏î‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏ö
            bet = max(CONFIG["unit_size"], required_bet)
        
        if bet >= CONFIG["stop_loss_threshold"]: bet = CONFIG["stop_loss_threshold"]
        if bet > max_bet_in_session: max_bet_in_session = bet

        # 3. Get Result
        if is_manual:
            prompt = f"üëâ [BET: {bet:,.1f}] Next (P/B/T/exit): "
            actual_result = input(prompt).upper().strip()
            if actual_result == "EXIT": return "OUT_OF_DATA", (bankroll - initial_bankroll), max_dd_in_session, max_bet_in_session, current_idx
            next_idx = current_idx + 1
        else:
            actual_result, next_idx = get_next_result(result_list, current_idx, is_random)
        
        if actual_result is None or actual_result == "":
            return "OUT_OF_DATA", (bankroll - initial_bankroll), max_dd_in_session, max_bet_in_session, current_idx

        current_idx = next_idx
        if actual_result == "T": continue

        is_win = (actual_result == "P" and CONFIG["side_preference"] == "PLAYER") or \
                 (actual_result == "B" and CONFIG["side_preference"] == "BANKER")
        
        if is_virtual_session:
            return ("WIN" if is_win else "LOSS"), 0, 0, 0, current_idx

        # 4. Update State & Bankroll
        payout = 0.95 if CONFIG["side_preference"] == "BANKER" else 1.0
        
        if CONFIG["show_hand_by_hand"]:
            hand_count += 1
            print(f"   Hand {hand_count:02d}: Bet {bet:7.1f} | Result: {'WIN ' if is_win else 'LOSS'} | Net: {bankroll + (bet*payout if is_win else -bet) - initial_bankroll:,.1f}")

        if is_win:
            bankroll += (bet * payout)
            consecutive_loss = 0 
            if state == "FIBO":
                fibo_idx = max(-1, fibo_idx - 2)
                if fibo_idx < 0: state, fibo_idx = "FLAT", 0
            else:
                if bankroll >= peak_bankroll: has_lost_since_peak = False
                state, mart_step = "FLAT", 0
        else:
            bankroll -= bet
            consecutive_loss += 1 
            has_lost_since_peak = True
            if state == "FLAT": state, mart_step = "MARTY", 1
            elif state == "MARTY":
                mart_step += 1
                if mart_step > CONFIG["marty_steps_limit"]: state, fibo_idx = "FIBO", 0
            elif state == "FIBO":
                fibo_idx += 1

        if bankroll > peak_bankroll: peak_bankroll = bankroll
        drawdown = peak_bankroll - bankroll
        if drawdown > max_dd_in_session: max_dd_in_session = drawdown
        
        if not is_virtual_session and consecutive_loss >= CONFIG["stop_after_consecutive_loss"]:
             return "STOP_LOSS", (bankroll - initial_bankroll), max_dd_in_session, max_bet_in_session, current_idx

        if (bankroll - initial_bankroll) >= target_profit: 
            return "WIN", (bankroll - initial_bankroll), max_dd_in_session, max_bet_in_session, current_idx
        
        if bankroll <= -1000000: 
            return "BUST", (bankroll - initial_bankroll), max_dd_in_session, max_bet_in_session, current_idx

def run_simulation(raw_data):
    mode = input("Select Mode: [D]ata string, [M]anual, or [R]andom probability? ").lower()
    is_manual = (mode == 'm')
    is_random = (mode == 'r')
    
    limit_hands = 0
    if is_random:
        limit_hands = int(input("Enter number of hands to simulate (e.g. 1000): "))

    full_results = []
    if not is_manual and not is_random:
        for line in raw_data.strip().split('\n'):
            if line.strip():
                full_results.extend([x.strip() for x in line.split(',')][1:])
        print(f"--- üìÇ Loaded {len(full_results)} hands ---")

    total_net_profit = 0.0
    current_idx = 0
    v_wins = 0
    session_no = 0
    global_max_bet = 0
    global_max_drawdown = 0
    peak_net_profit = 0

    while True:
        if not is_manual and not is_random and current_idx >= len(full_results): break
        if is_random and current_idx >= limit_hands: break

        # üß™ Virtual Wait
        # ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡∏ä‡∏ô‡∏∞‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ï‡∏≤‡∏° trigger ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏•‡∏° (Virtual) ‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô
        if v_wins < CONFIG["virtual_win_trigger"]:
            res, _, _, _, next_idx = run_single_session(
                full_results, current_idx, 999999, CONFIG["unit_size"], 100000, 
                is_virtual_session=True, is_manual=is_manual, is_random=is_random
            )
            current_idx = next_idx
            if res == "OUT_OF_DATA": break
            v_wins = v_wins + 1 if res == "WIN" else 0
            continue

        # üí∞ Real Session
        session_no += 1
        current_bankroll = CONFIG["initial_bankroll"] + total_net_profit
        target = CONFIG["unit_size"] if total_net_profit >= 0 else abs(total_net_profit) + CONFIG["unit_size"]
        
        active_unit = CONFIG["unit_size"]
        if total_net_profit < 0:
            if CONFIG["recovery_mode"] == 'aggressive':
                active_unit = max(CONFIG["unit_size"], target / CONFIG["recovery_ratio"])
            
            cap_limit = max(current_bankroll, CONFIG["unit_size"]) * CONFIG["max_unit_cap"]
            active_unit = min(active_unit, cap_limit)
        
        # --- FIX: ‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏© active_unit ‡πÉ‡∏´‡πâ‡∏•‡∏á‡∏ï‡∏±‡∏ß‡∏Å‡∏±‡∏ö chip_size ‡πÄ‡∏™‡∏°‡∏≠ ---
        active_unit = math.ceil(active_unit / CONFIG["chip_size"]) * CONFIG["chip_size"]
        active_unit = max(active_unit, CONFIG["chip_size"])
        
        if CONFIG["show_hand_by_hand"]:
            print(f"\nüîî Session {session_no} | Target: {target:.1f} | Base Unit: {active_unit:.1f} | Current Net: {total_net_profit:.1f}")

        status, profit, mdd, mbet, next_idx = run_single_session(
            full_results, current_idx, target, active_unit, current_bankroll, 
            is_manual=is_manual, is_random=is_random
        )
        
        current_idx = next_idx
        total_net_profit += profit
        
        # ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏ö Session ‡∏à‡∏£‡∏¥‡∏á ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï v_wins ‡πÄ‡∏õ‡πá‡∏ô 0 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠ Virtual Win ‡πÉ‡∏´‡∏°‡πà
        v_wins = 0 
        
        if mbet > global_max_bet: global_max_bet = mbet
        if total_net_profit > peak_net_profit: peak_net_profit = total_net_profit
        current_global_dd = peak_net_profit - total_net_profit
        if current_global_dd > global_max_drawdown: global_max_drawdown = current_global_dd

        print(f"[Session {session_no:02d}] Status: {status:9s} | Net: {total_net_profit:8.1f}")
        if status == "OUT_OF_DATA": break

    print(f"\n{'‚ïê'*40}\nüèÅ SIMULATION COMPLETED\n{'‚ïê'*40}")
    print(f"üí∞ Final Net Profit: {total_net_profit:,.2f}")
    print(f"üî• Global Max Bet:   {global_max_bet:,.2f}")
    print(f"üìâ Global Max DD:    {global_max_drawdown:,.2f}\n{'‚ïê'*40}")

if __name__ == "__main__":
    raw_input_data = """
   1,P,B,B,B,P,B,P,P,T,P,P,T,P,B,B,B,P,P,P,B,P,B,P,B,B,P,B,B,P,T,P,B,B,B,B,B,P,P,T,T,P,P,P,B,B,P,B,B,T,P,B,P,B,P,P,P,P,T,B,P,P,B,T,T,P,P,P,B,P,P,B,B,P,B,P,P,B,B,P,P,B,B,B
2,P,B,B,P,P,P,B,P,P,T,B,B,B,B,B,P,B,T,P,P,T,B,P,B,B,P,P,B,B,B,B,P,B,B,T,B,P,T,P,P,P,P,P,B,P,B,P,P,P,P,B,P,B,P,P,T,B,P,B,P,B,B,P,P,T,P,P,B,P,T,B,B,P,P,P,P,B,P,B,P
3,B,B,P,P,B,P,B,B,B,P,B,B,B,B,B,P,P,P,P,P,B,T,P,B,T,B,T,B,B,P,B,P,P,P,B,B,P,B,B,P,P,B,P,B,T,B,P,P,B,P,P,B,T,B,P,B,P,B,P,B,B,B,B,P,T,T,P,T,B,B,B,B,P,B,P,B,P,B,P,P,P
    """
    run_simulation(raw_input_data)
