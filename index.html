<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Baccarat AI: Ultimate V3.2 (Sniper Fixed)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #2c3e50; --accent: #e74c3c; --player: #2980b9; --banker: #c0392b;
            --tie: #27ae60; --bg: #f4f6f7; --card-bg: #ffffff; --text: #2c3e50;
            --gray-light: #f8f9fa; --success: #27ae60; --warning: #f39c12; --danger: #c0392b; --auto: #8e44ad;
            --gold: #d4ac0d; --chaos: #8e44ad; --dragon: #e67e22; --target: #16a085;
        }
        body { font-family: 'Segoe UI', 'Sarabun', sans-serif; background-color: var(--bg); color: var(--text); margin: 0; padding: 10px; display: flex; justify-content: center; height: 100vh; overflow: hidden; }
        .container { width: 100%; max-width: 1200px; display: grid; grid-template-columns: 350px 1fr; gap: 15px; height: 95vh; }
        .sidebar { background: var(--card-bg); padding: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); overflow-y: auto; display: flex; flex-direction: column; gap: 10px; height: 100%; border-top: 5px solid var(--target); }
        .section-title { font-size: 0.85rem; font-weight: bold; color: var(--primary); margin-top: 5px; border-bottom: 2px solid #eee; padding-bottom: 3px; display: flex; justify-content: space-between; align-items: center; }
        .badge-ult { background: var(--target); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.6rem; box-shadow: 0 2px 4px rgba(22, 160, 133, 0.3); }
        .form-group { margin-bottom: 5px; }
        .form-group label { display: block; font-size: 0.8rem; font-weight: 600; margin-bottom: 2px; color: #555; }
        .form-group input, .form-group select { width: 100%; padding: 8px; border: 1px solid #bdc3c7; border-radius: 5px; font-size: 0.95rem; box-sizing: border-box; transition: all 0.2s; }
        .form-group input:focus, .form-group select:focus { border-color: var(--accent); outline: none; box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.1); }
        
        /* V3.1 Specific Styles */
        .feature-box { background: #fffcf5; border: 1px solid #fae5d3; border-radius: 8px; padding: 8px; margin-bottom: 5px; }
        .feature-title { font-size: 0.75rem; font-weight: bold; color: #d35400; margin-bottom: 5px; display: flex; justify-content: space-between; }
        .dual-input { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .survival-active { animation: pulse-red 2s infinite; border: 2px solid var(--danger); }
        
        .target-box { background: #e8f8f5; border: 1px solid #a3e4d7; border-radius: 8px; padding: 8px; margin-bottom: 5px; }
        .target-title { font-size: 0.75rem; font-weight: bold; color: var(--target); margin-bottom: 5px; }

        .monitor-box { background: #2c3e50; border-radius: 8px; padding: 12px; margin-bottom: 5px; text-align: center; color: white; box-shadow: 0 4px 10px rgba(44, 62, 80, 0.2); }
        .monitor-label { font-size: 0.7rem; color: #bdc3c7; font-weight: 600; display: block; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 1px; }
        .monitor-val { font-size: 1.2rem; font-weight: bold; color: var(--gold); text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        
        .cycle-monitor { display: flex; justify-content: space-between; background: rgba(0,0,0,0.2); padding: 5px 10px; border-radius: 4px; margin-top: 5px; font-size: 0.8rem; }
        
        .brain-monitor { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .brain-col { text-align: center; }
        .brain-head { font-size: 0.7rem; font-weight: bold; margin-bottom: 2px; }
        .brain-val { font-size: 1.1rem; font-weight: 800; }
        .brain-info { font-size: 0.65rem; color: #7f8c8d; }
        .txt-p { color: var(--player); } .txt-b { color: var(--banker); }
        
        .btn-action { width: 100%; padding: 12px; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 0.9rem; margin-top: 5px; transition: transform 0.1s; }
        .btn-action:active { transform: scale(0.98); }
        .btn-sim { background: var(--primary); }
        .btn-auto { background: var(--auto); position: relative; overflow: hidden; }
        .btn-stop { background: var(--danger); display: none; }
        .btn-reset { background: #ecf0f1; color: #7f8c8d; border: 1px solid #bdc3c7; margin-top: 10px; }
        .btn-reset:hover { background: #bdc3c7; color: white; }
        .btn-restore { background: white; border: 1px dashed var(--target); color: var(--target); font-size: 0.75rem; width: 100%; cursor: pointer; padding: 6px; margin-top: 5px; border-radius: 4px; font-weight: bold; }

        .main-content { display: flex; flex-direction: column; gap: 15px; overflow-y: auto; padding-right: 5px; height: 100%; }
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; flex-shrink: 0; }
        .stat-card { background: var(--card-bg); padding: 10px; border-radius: 10px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.03); border-top: 4px solid transparent; }
        .stat-card.profit { border-top-color: var(--success); } .stat-card.loss { border-top-color: var(--danger); } .stat-card.pre { border-top-color: var(--gold); background: #fffcf5; }
        .stat-label { font-size: 0.65rem; color: #95a5a6; text-transform: uppercase; line-height: 1.2; }
        .stat-value { font-size: 1rem; font-weight: 800; margin-top: 3px; }
        
        .road-scroll-wrapper { background: var(--card-bg); padding: 10px; border-radius: 10px; box-shadow: inset 0 0 10px rgba(0,0,0,0.02); overflow-x: auto; overflow-y: hidden; height: 170px; min-height: 170px; flex-shrink: 0; width: 100%; box-sizing: border-box; scroll-behavior: smooth; }
        .big-road-grid { display: grid; grid-template-rows: repeat(6, 26px); grid-auto-columns: 26px; grid-auto-flow: column; gap: 1px; min-width: max-content; }
        .big-road-cell { width: 24px; height: 24px; display: flex; justify-content: center; align-items: center; font-size: 10px; font-weight: bold; border: 1px solid #f0f0f0; background: white; }
        .circle { width: 18px; height: 18px; border-radius: 50%; border: 2px solid transparent; display: flex; justify-content: center; align-items: center; background: transparent; }
        .circle-P { border-color: var(--player); color: var(--player); } .circle-B { border-color: var(--banker); color: var(--banker); } .circle-T { border-color: var(--tie); color: var(--tie); }
        
        .bet-panel { background: var(--card-bg); padding: 15px; border-radius: 12px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.08); flex-shrink: 0; border-bottom: 5px solid var(--primary); }
        .offset-formula { font-family: monospace; font-size: 0.9rem; color: #7f8c8d; background: #f0f3f4; padding: 4px 10px; border-radius: 4px; display: inline-block; margin-bottom: 10px; }
        .rec-amount { font-size: 3.5rem; font-weight: 900; line-height: 1; color: var(--primary); text-shadow: 2px 2px 0px #eee; }
        .rec-side { font-size: 1.8rem; font-weight: 800; margin-top: 5px; text-transform: uppercase; letter-spacing: 2px; }
        .side-p { color: var(--player); } .side-b { color: var(--banker); } .side-n { color: #95a5a6; } .side-chaos { color: var(--chaos); } .side-dragon { color: var(--dragon); }
        
        .controls { display: grid; grid-template-columns: 1fr 1fr 80px; gap: 10px; margin-top: 15px; }
        .btn-ctrl { padding: 15px; border: none; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; color: white; touch-action: manipulation; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s; }
        .btn-ctrl:active { transform: translateY(2px); }
        .btn-p { background: var(--player); } .btn-b { background: var(--banker); } .btn-u { background: #95a5a6; }
        
        .chart-box { background: var(--card-bg); padding: 10px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); flex-grow: 1; min-height: 250px; position: relative; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 999999; backdrop-filter: blur(5px); }
        .modal-box { background: white; padding: 30px 20px; border-radius: 15px; text-align: center; max-width: 400px; width: 85%; box-shadow: 0 20px 50px rgba(0,0,0,0.4); display: flex; flex-direction: column; align-items: center; border: 2px solid var(--gold); }
        .modal-icon { font-size: 4rem; margin-bottom: 15px; }
        .modal-text-th { font-size: 1.2rem; font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .modal-sub { font-size: 1rem; color: var(--success); font-weight: bold; margin-bottom: 15px; }
        .btn-modal-ack { background: var(--success); color: white; border: none; padding: 12px 20px; width: 100%; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem; margin-top: 15px; }
        
        .risk-stat-box { background: #fdedec; border: 1px solid #fadbd8; padding: 10px; width: 100%; border-radius: 8px; margin-bottom: 15px; text-align: left; }
        .risk-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; }
        .risk-val { font-weight: bold; color: #c0392b; }

        @media (max-width: 768px) {
            body { overflow-y: auto; height: auto; display: block; }
            .container { grid-template-columns: 1fr; height: auto; display: flex; flex-direction: column; gap: 20px; padding-bottom: 30px; overflow: visible; }
            .sidebar { height: auto; margin-bottom: 0; flex-shrink: 0; }
            .main-content { height: auto; overflow: visible; }
            .road-scroll-wrapper { min-height: 170px; width: 100%; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .chart-box { min-height: 300px; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="sidebar">
        <!-- Header Title -->
        <div class="section-title" style="justify-content: center; border-bottom: none;">
            <span class="badge-ult" style="font-size: 0.8rem; padding: 5px 10px;">V3.2 SNIPER MODE</span>
        </div>

        <!-- MOVED: Simulation Tools (Top) -->
        <div class="section-title">üß™ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Simulation)</div>
        <div class="form-group">
            <input type="number" id="sim_hands" value="1" placeholder="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡∏≤ (Hands)">
            <button class="btn-action btn-sim" onclick="runSimulation()">‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Simulate)</button>
            <label style="margin-top:10px;">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß Auto Sim:</label>
            <select id="sim_speed" style="margin-bottom:5px;">
                <option value="0">üöÄ ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (Instant)</option>
                <option value="100" selected>‚ö° ‡πÄ‡∏£‡πá‡∏ß (Fast)</option>
            </select>
            <button class="btn-action btn-auto" id="btn_auto_sim" onclick="toggleAutoSim()">üöÄ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á (Auto Sim)</button>
            <button class="btn-action btn-stop" id="btn_stop_sim" onclick="stopAutoSim()">‚èπ ‡∏´‡∏¢‡∏∏‡∏î (STOP)</button>
            <div id="sim_stats_display" class="sim-stats" style="display:none; font-size:0.75rem; text-align:center; margin-top:5px;">
                ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà: <span id="sim_round_count">0</span> | ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: <span id="sim_success_count" style="color:green;">0</span>
            </div>
        </div>

        <!-- Settings Section -->
        <div class="section-title">‚öôÔ∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (Settings)</div>
        
        <div class="form-group">
            <label>‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå (Strategy Mode)</label>
            <select id="strat_mode" onchange="updateUI()"> 
                <option value="offset" selected>‚öñÔ∏è Offset (‡∏™‡∏°‡∏î‡∏∏‡∏• P-B) [Default]</option>
                <option value="anti_last">‚ö° Anti Last (‡∏™‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏¥‡∏î)</option>
                <option value="follow_last">üåä Follow Last (‡∏ï‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏ï‡∏¥‡∏î)</option>
            </select>
        </div>

        <!-- V3.1 Target Profit Feature -->
        <div class="target-box">
            <div class="target-title">üéØ Target Profit (‡πÄ‡∏õ‡πâ‡∏≤‡∏Å‡∏≥‡πÑ‡∏£‡∏ï‡πà‡∏≠‡∏£‡∏≠‡∏ö)</div>
            <div class="form-group">
                <label>Reset Cycle if Profit >=</label>
                <input type="number" id="target_profit" value="1" placeholder="‡πÄ‡∏ä‡πà‡∏ô 20 ‡∏´‡∏ô‡πà‡∏ß‡∏¢">
                <div style="font-size:0.65rem; color:#16a085; margin-top:2px;">*‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏•‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏Å‡∏•‡πâ‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤ (Sniper Mode)</div>
            </div>
        </div>

        <div class="feature-box" style="border-color: var(--dragon);">
            <div class="feature-title" style="color: var(--dragon);">üêâ Dragon Logic (‡∏ï‡∏±‡∏î‡∏°‡∏±‡∏á‡∏Å‡∏£)</div>
            <div class="form-group">
                <label>Stop if Streak >= (‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏±‡∏á‡∏Å‡∏£‡∏¢‡∏≤‡∏ß)</label>
                <input type="number" id="dragon_limit" value="7" placeholder="7">
            </div>
        </div>

        <div class="feature-box">
            <div class="feature-title">üîí Trailing Stop (‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≥‡πÑ‡∏£ V3)</div>
            <div class="dual-input">
                <div class="form-group">
                    <label>Start (Profit)</label>
                    <input type="number" id="trail_start" value="11">
                </div>
                <div class="form-group">
                    <label>Drop (%)</label>
                    <input type="number" id="trail_drop" value="17.3">
                </div>
            </div>
        </div>

        <div class="feature-box">
            <div class="feature-title">üå™Ô∏è Chaos Filter (‡∏Å‡∏£‡∏≠‡∏á‡πÑ‡∏û‡πà‡∏°‡∏±‡πà‡∏ß)</div>
            <div class="form-group">
                <label>Zigzag Limit (Last 10)</label>
                <select id="chaos_limit">
                    <option value="5" selected>5/10 (Strict V3)</option>
                    <option value="9">9/10 (Relaxed)</option>
                    <option value="11">Disable</option>
                </select>
            </div>
        </div>

        <div class="feature-box" id="survival_box">
            <div class="feature-title">üõ°Ô∏è Survival Mode (‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏≠‡∏≤‡∏ï‡∏±‡∏ß‡∏£‡∏≠‡∏î)</div>
            <div class="dual-input">
                <div class="form-group">
                    <label>Trigger DD%</label>
                    <input type="number" id="surv_trigger" value="46">
                </div>
                <div class="form-group">
                    <label>Div Multiplier</label>
                    <input type="number" id="surv_div" value="2.04">
                </div>
            </div>
        </div>

        <div class="form-group">
            <label>‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô (Bankroll) 405-4000000</label>
            <input type="number" id="init_bank" value="4000000">
        </div>

        <div class="form-group">
            <label>Stop Loss (Reset Threshold)</label>
            <input type="number" id="stop_loss" value="10605" style="color:var(--danger); font-weight:bold;">
        </div>

        <div class="form-group">
            <label>Max Bet Cap (7.1% of Capital)</label>
            <input type="number" id="max_bet_cap" value="71000">
        </div>
        
        <div class="form-group">
            <label>Rebalance Adaptivity</label>
            <input type="number" id="rebalance_val" value="4.62" step="0.01">
        </div>

        <div class="form-group">
            <label>‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (Min Bet)</label>
            <input type="number" id="min_bet" value="5">
        </div>

        <button class="btn-restore" onclick="restoreRecommended()">‚Ü∫ ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ Ultimate V3.2</button>

        <div class="section-title">üéØ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ (Status)</div>
        <div class="monitor-box">
            <span class="monitor-label">‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ / High Water Mark</span>
            <div id="target_status_display" class="monitor-val">0 / 0</div>
            
            <div class="cycle-monitor">
                <span>Cycle Profit:</span>
                <span id="cycle_profit_disp" style="color: var(--target); font-weight:bold;">0</span>
            </div>
            
            <div style="font-size:0.6rem; color:#bdc3c7; margin-top:4px;" id="trailing_info">Trailing Inactive</div>
        </div>

        <div class="section-title">üß† AI Brain Monitor</div>
        <div class="brain-monitor">
            <div class="brain-col">
                <div class="brain-head txt-p">PLAYER AI</div>
                <div class="brain-val txt-p" id="mon_p_req">0</div>
                <div class="brain-info" id="mon_p_info">Wait: 0</div>
            </div>
            <div class="brain-col">
                <div class="brain-head txt-b">BANKER AI</div>
                <div class="brain-val txt-b" id="mon_b_req">0</div>
                <div class="brain-info" id="mon_b_info">Wait: 0</div>
            </div>
        </div>

        <button class="btn-reset" onclick="resetAll()">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (Hard Reset)</button>
    </div>

    <div class="main-content">
        <div class="stats-grid">
            <div class="stat-card profit">
                <div class="stat-label">‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ (Net Profit)</div>
                <div class="stat-value" id="disp_net">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Max Drawdown</div>
                <div class="stat-value" id="disp_dd">0</div>
            </div>
            <div class="stat-card loss">
                <div class="stat-label">Max Bet (Real)</div>
                <div class="stat-value" id="disp_maxbet">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏∑‡∏≠ (Hands)</div>
                <div class="stat-value" id="disp_hands">0</div>
            </div>
            <div class="stat-card pre">
                <div class="stat-label">Dragon Streak<br>(Current)</div>
                <div class="stat-value" id="disp_dragon">0</div>
            </div>
            <div class="stat-card pre">
                <div class="stat-label">Chaos Count<br>(Last 10)</div>
                <div class="stat-value" id="disp_chaos">0</div>
            </div>
        </div>

        <div class="road-scroll-wrapper">
            <div class="big-road-grid" id="road_container"></div>
        </div>

        <div class="bet-panel">
            <div class="offset-formula" id="formula_disp">Strategy: Offset</div>
            <div class="rec-amount" id="rec_amount">0</div>
            <div class="rec-side side-n" id="rec_side">WAIT</div>
            <div class="controls">
                <button class="btn-ctrl btn-p" onclick="processResult('P')">PLAYER</button>
                <button class="btn-ctrl btn-b" onclick="processResult('B')">BANKER</button>
                <button class="btn-ctrl btn-u" onclick="undo()">UNDO</button>
            </div>
        </div>
        <div class="chart-box">
            <canvas id="profitChart"></canvas>
        </div>
    </div>
</div>

<div class="modal-overlay" id="winModal">
    <div class="modal-box">
        <div class="modal-icon">üéØ</div>
        <div class="modal-text-th" id="modal_title">Target Hit!</div>
        <div class="modal-sub" id="modal_profit_show">+20 Units</div>
        <div class="modal-text-th" style="font-size:0.9rem; color:#7f8c8d;">System Reset Betting Progression</div>
        <button class="btn-modal-ack" onclick="closeWinModal()">‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà)</button>
    </div>
</div>

<div class="modal-overlay" id="riskModal">
    <div class="modal-box" style="border-top: 5px solid #c0392b;">
        <div class="modal-icon">‚ö†Ô∏è</div>
        <div class="modal-text-th" style="color:#c0392b;">Stop Loss / Logic Stop</div>
        <div class="risk-stat-box">
            <div class="risk-row"><span>Reason:</span><span class="risk-val" id="risk_reason">-</span></div>
            <div class="risk-row"><span>Drawdown:</span><span class="risk-val" id="risk_dd">-</span></div>
        </div>
        <button class="btn-modal-ack" style="background:#c0392b;" onclick="closeRiskModal()">‡∏õ‡∏¥‡∏î (Close)</button>
    </div>
</div>

<script>
    let state = { 
        realBalance: 0, history: [], maxDrawdown: 0, maxBet: 0, 
        highWaterMark: 0, targetReached: false, survivalActive: false,
        cycleStartBalance: 0, // V3.1: Track start of current cycle
        pStrat: { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 }, 
        bStrat: { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 }, 
        graphData: [0], graphLabels: [0] 
    };
    let undoStack = [];
    let chartInstance = null;
    let isAutoRunning = false;
    let simRoundCount = 0;
    let simSuccessCount = 0;
    let autoTimer = null; 

    const DEFAULT_DIVISOR = 2.0;

    function restoreRecommended() {
        document.getElementById('init_bank').value = 4000000;
        document.getElementById('strat_mode').value = "offset";
        
        // V3.1 Defaults
        document.getElementById('target_profit').value = 1; // Default Target
        document.getElementById('trail_start').value = 11;
        document.getElementById('trail_drop').value = 17.3;
        document.getElementById('chaos_limit').value = 5;
        document.getElementById('surv_trigger').value = 46;
        document.getElementById('surv_div').value = 2.04;
        document.getElementById('dragon_limit').value = 7;
        document.getElementById('max_bet_cap').value = 71000;
        
        document.getElementById('rebalance_val').value = 4.62;
        document.getElementById('stop_loss').value = 10605;
        updateUI();
    }

    function calculateDivisor(deficit, minBet) {
        let baseDiv = DEFAULT_DIVISOR;
        const bank = parseFloat(document.getElementById('init_bank').value);
        const survTrigger = parseFloat(document.getElementById('surv_trigger').value);
        const survMult = parseFloat(document.getElementById('surv_div').value);
        
        let currentDD = Math.abs(state.realBalance);
        if (state.realBalance >= 0) currentDD = 0;
        let ddPercent = (currentDD / bank) * 100;

        if (ddPercent >= survTrigger) {
            baseDiv *= survMult;
            state.survivalActive = true;
        } else {
            state.survivalActive = false;
        }

        if (deficit > 500 * minBet) baseDiv -= 0.1;
        if (deficit > 2000 * minBet) baseDiv -= 0.1;
        if (deficit > 5000 * minBet) baseDiv -= 0.1;
        if (baseDiv < 1.5) baseDiv = 1.5;

        return baseDiv;
    }

    function getRawBet(strat, side) {
        const minBet = parseFloat(document.getElementById('min_bet').value);
        let bet = 0;

        if (strat.stage >= 1) {
            bet = strat.initBet * Math.pow(2, strat.stage);
        } else if (strat.wait >= 1) {
            let deficit = Math.abs(strat.bal);
            if (deficit > 0) {
                let div = calculateDivisor(deficit, minBet);
                div = div * Math.pow(1.04, strat.cons_loss || 0);
                let needed = deficit + minBet;
                bet = Math.ceil(needed / div);
                if (bet < minBet) bet = minBet;
            } else {
                bet = minBet;
            }
        }
        return bet;
    }

    function updateAI(strat, side, isPWin, rawBet) {
        const isWin = (side === 'P' && isPWin) || (side === 'B' && !isPWin);
        if (isWin) {
            strat.wait++;
            strat.cons_loss = 0;
            let profit = (side === 'P') ? rawBet : (rawBet * 0.95);
            strat.bal += profit;
            if (rawBet > 0) {
                if (strat.stage === 0) { strat.initBet = rawBet; strat.stage = 1; } else { strat.stage++; }
            }
        } else {
            strat.wait = 0;
            strat.cons_loss = (strat.cons_loss || 0) + 1;
            if (rawBet > 0) { strat.bal -= rawBet; strat.stage = 0; }
        }
    }

    function checkChaos() {
        if (state.history.length < 10) return 0;
        let slice = state.history.slice(-10);
        let zigzags = 0;
        for (let i = 0; i < slice.length - 1; i++) {
            if (slice[i] !== slice[i+1]) zigzags++;
        }
        return zigzags;
    }

    function checkDragon() {
        if (state.history.length < 2) return 1;
        let last = state.history[state.history.length - 1];
        let count = 1;
        for (let i = state.history.length - 2; i >= 0; i--) {
            if (state.history[i] === last) count++;
            else break;
        }
        return count;
    }

    // --- V3.2 SNIPER LOGIC ---
    function applyTargetSniper(betAmount, side) {
        const targetProfit = parseFloat(document.getElementById('target_profit').value);
        const minBet = parseFloat(document.getElementById('min_bet').value);
        
        if (targetProfit <= 0) return betAmount; // Feature disabled
        
        const currentCycleProfit = state.realBalance - state.cycleStartBalance;
        const needed = targetProfit - currentCycleProfit;
        
        // If we are close to target (needed > 0) and the bet is larger than what we need
        if (needed > 0 && betAmount > needed) {
            let capped = needed;
            // If Banker, we need to bet slightly more to cover 5% commission
            if (side === 'B' || side === 'BANKER') {
                capped = needed / 0.95;
            }
            capped = Math.ceil(capped);
            
            // Ensure we don't go below min bet
            return Math.max(capped, minBet);
        }
        return betAmount;
    }

    function processResult(res, isSim = false) {
        if (!isSim) saveState();
        const isPWin = (res === 'P');
        const unit = parseFloat(document.getElementById('min_bet').value);
        const stratMode = document.getElementById('strat_mode').value;
        const maxBetCap = parseFloat(document.getElementById('max_bet_cap').value);
        const chaosLimit = parseInt(document.getElementById('chaos_limit').value);
        const dragonLimit = parseInt(document.getElementById('dragon_limit').value);
        const targetProfit = parseFloat(document.getElementById('target_profit').value);

        // 1. Check Filters
        let chaosCount = checkChaos();
        let dragonCount = checkDragon();
        let isChaos = chaosCount >= chaosLimit;
        let isDragon = dragonCount >= dragonLimit;

        if (isChaos || isDragon) {
            state.history.push(res);
            state.graphData.push(state.realBalance);
            state.graphLabels.push(state.history.length);
            if (!isSim) updateUI();
            return; 
        }

        // 2. Calculate AI Bets
        const rawP = getRawBet(state.pStrat, 'P');
        const rawB = getRawBet(state.bStrat, 'B');

        // 3. Strategy Logic
        let netBet = 0, netSide = null;

        if (stratMode === 'offset') {
            if (rawP > rawB) { netBet = rawP - rawB; netSide = 'P'; } 
            else if (rawB > rawP) { netBet = rawB - rawP; netSide = 'B'; }
        } else {
            let lastRes = state.history.length > 0 ? state.history[state.history.length - 1] : null;
            let trendSide = 'P'; 
            if (lastRes) {
                trendSide = (stratMode === 'anti_last') ? (lastRes === 'P' ? 'B' : 'P') : (lastRes === 'P' ? 'P' : 'B');
            }
            let systemBet = Math.max(rawP, rawB);
            netSide = trendSide;
            netBet = systemBet;
        }

        // --- V3.2 Apply Sniper Cap (Before Bet) ---
        if (netBet > 0) {
            netBet = applyTargetSniper(netBet, netSide);
        }

        if (netBet > maxBetCap) netBet = maxBetCap;

        // 5. Execute Bet
        if (netBet > 0) {
            if (netSide === 'P') state.realBalance += isPWin ? netBet : -netBet;
            else state.realBalance += !isPWin ? (netBet * 0.95) : -netBet;
        }

        // 6. Update AI Internal State
        updateAI(state.pStrat, 'P', isPWin, rawP);
        updateAI(state.bStrat, 'B', isPWin, rawB);

        // 7. Dynamic Rebalance
        const rebalanceVal = parseFloat(document.getElementById('rebalance_val').value);
        if (Math.abs(state.pStrat.bal - state.bStrat.bal) > 100) {
            let avg = (state.pStrat.bal + state.bStrat.bal) / 2;
            state.pStrat.bal += (avg - state.pStrat.bal) * 0.01;
            state.bStrat.bal += (avg - state.bStrat.bal) * 0.01;
        }

        state.history.push(res);
        state.graphData.push(state.realBalance);
        state.graphLabels.push(state.history.length);
        
        if (state.realBalance < state.maxDrawdown) state.maxDrawdown = state.realBalance;
        if (netBet > state.maxBet) state.maxBet = netBet;

        // --- V3.1 LOGIC: TARGET PROFIT & TRAILING STOP ---
        
        // A. Target Profit Check (Priority)
        let cycleProfit = state.realBalance - state.cycleStartBalance;
        
        if (targetProfit > 0 && cycleProfit >= targetProfit) {
            if (!isSim && !state.targetReached) {
                showWinModal(false, cycleProfit); // false = Target Hit
                state.targetReached = true;
            }
            // RESET CYCLE
            state.pStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 };
            state.bStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 };
            state.cycleStartBalance = state.realBalance; // Set new baseline
            state.highWaterMark = state.realBalance; // Reset HWM for trailing
            state.targetReached = false; // Allow next trigger
        }
        
        // B. Trailing Stop Check (Secondary)
        const trailStart = parseFloat(document.getElementById('trail_start').value);
        const trailDrop = parseFloat(document.getElementById('trail_drop').value);
        
        if (state.realBalance >= trailStart) {
            if (state.realBalance > state.highWaterMark) state.highWaterMark = state.realBalance;
        }

        if (state.highWaterMark >= trailStart) {
            let cutLine = state.highWaterMark * (1 - (trailDrop / 100));
            if (state.realBalance <= cutLine) {
                if (!state.targetReached) {
                    // Only show if we haven't just hit the main target
                    showWinModal(true, 0); // true = Trailing
                    state.targetReached = true;
                }
                // Bet Reduction
                state.pStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 };
                state.bStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 };
                state.highWaterMark = state.realBalance;
                state.cycleStartBalance = state.realBalance; // Also reset cycle baseline on trailing stop
                state.targetReached = false; 
            }
        }

        if (!isSim) updateUI();
    }

    function updateUI() {
        const unit = parseFloat(document.getElementById('min_bet').value);
        const stratMode = document.getElementById('strat_mode').value;
        const maxBetCap = parseFloat(document.getElementById('max_bet_cap').value);
        const chaosLimit = parseInt(document.getElementById('chaos_limit').value);
        const dragonLimit = parseInt(document.getElementById('dragon_limit').value);

        let chaosCount = checkChaos();
        let dragonCount = checkDragon();
        let isChaos = chaosCount >= chaosLimit;
        let isDragon = dragonCount >= dragonLimit;

        const pObj = getRawBet(state.pStrat, 'P');
        const bObj = getRawBet(state.bStrat, 'B');
        const nextP = pObj, nextB = bObj;
        
        let netAmt = 0, netSide = "WAIT", formula = "", sideClass = "side-n";

        if (isDragon) {
            netSide = "DRAGON";
            netAmt = 0;
            sideClass = "side-dragon";
            formula = `Dragon Limit Active (Streak ${dragonCount})`;
        } else if (isChaos) {
            netSide = "CHAOS";
            netAmt = 0;
            sideClass = "side-chaos";
            formula = `Chaos Filter Active (${chaosCount}/${chaosLimit})`;
        } else if (stratMode === 'offset') {
            if (nextP > nextB) { netAmt = nextP - nextB; netSide = "PLAYER"; sideClass = "side-p"; }
            else if (nextB > nextP) { netAmt = nextB - nextP; netSide = "BANKER"; sideClass = "side-b"; }
            formula = `Offset: P${nextP} vs B${nextB}`;
        } else {
            let lastRes = state.history.length > 0 ? state.history[state.history.length - 1] : null;
            let trendSide = 'P';
            if (lastRes) {
                trendSide = (stratMode === 'anti_last') ? (lastRes === 'P' ? 'BANKER' : 'PLAYER') : (lastRes === 'P' ? 'PLAYER' : 'BANKER');
            }
            let systemBet = Math.max(nextP, nextB);
            netSide = trendSide;
            netAmt = systemBet;
            sideClass = trendSide === 'PLAYER' ? 'side-p' : 'side-b';
            formula = `${stratMode === 'anti_last' ? 'Anti' : 'Follow'} Last`;
        }

        // --- V3.2 UI Display Sniper Cap ---
        let originalAmt = netAmt;
        if (netAmt > 0) {
            netAmt = applyTargetSniper(netAmt, netSide);
        }
        if (originalAmt > netAmt) {
            formula += " [Sniper Active]";
        }

        if (netAmt > maxBetCap) netAmt = maxBetCap;

        document.getElementById('rec_amount').innerText = netAmt.toLocaleString();
        document.getElementById('rec_side').innerText = netSide;
        document.getElementById('rec_side').className = `rec-side ${sideClass}`;
        document.getElementById('formula_disp').innerText = formula;

        document.getElementById('mon_p_req').innerText = Math.round(state.pStrat.bal).toLocaleString();
        document.getElementById('mon_b_req').innerText = Math.round(state.bStrat.bal).toLocaleString();
        document.getElementById('mon_p_info').innerText = `Wait:${state.pStrat.wait} | Stg:${state.pStrat.stage}`;
        document.getElementById('mon_b_info').innerText = `Wait:${state.bStrat.wait} | Stg:${state.bStrat.stage}`;

        const statusElem = document.getElementById('target_status_display');
        statusElem.innerText = `${state.realBalance.toFixed(2)} / ${state.highWaterMark.toFixed(2)}`;
        
        // Cycle Profit Display
        let cycleProfit = state.realBalance - state.cycleStartBalance;
        let targetProfit = parseFloat(document.getElementById('target_profit').value);
        document.getElementById('cycle_profit_disp').innerText = `${cycleProfit.toFixed(2)} / ${targetProfit}`;

        const trailStart = parseFloat(document.getElementById('trail_start').value);
        let trailMsg = state.highWaterMark >= trailStart ? `Active` : `Waiting`;
        document.getElementById('trailing_info').innerText = trailMsg;

        const profitElem = document.getElementById('disp_net');
        profitElem.innerText = state.realBalance.toLocaleString(undefined, {minimumFractionDigits: 2});
        profitElem.style.color = state.realBalance >= 0 ? 'var(--success)' : 'var(--danger)';

        document.getElementById('disp_dd').innerText = state.maxDrawdown.toLocaleString(undefined, {minimumFractionDigits: 2});
        document.getElementById('disp_maxbet').innerText = state.maxBet.toLocaleString();
        document.getElementById('disp_hands').innerText = state.history.length;
        document.getElementById('disp_chaos').innerText = `${chaosCount} / ${chaosLimit}`;
        document.getElementById('disp_dragon').innerText = dragonCount;
        
        if (state.survivalActive) document.getElementById('survival_box').classList.add('survival-active');
        else document.getElementById('survival_box').classList.remove('survival-active');

        document.getElementById('sim_round_count').innerText = simRoundCount;
        document.getElementById('sim_success_count').innerText = simSuccessCount;

        renderBigRoad();
        updateChart();
    }

    function renderBigRoad() {
        const roadDiv = document.getElementById('road_container');
        roadDiv.innerHTML = '';
        let matrix = [], col = 0, row = 0, lastWinner = null;
        const setCell = (c, r, val) => { if (!matrix[c]) matrix[c] = []; matrix[c][r] = val; };
        state.history.forEach(res => {
            if (lastWinner === null) { setCell(col, row, res); lastWinner = res; }
            else {
                if (res === lastWinner) {
                    if (row < 5 && (!matrix[col] || matrix[col][row+1] === undefined)) row++; else col++;
                    setCell(col, row, res);
                } else { col++; row = 0; setCell(col, row, res); lastWinner = res; }
            }
        });
        const maxCol = matrix.length, renderCols = Math.max(20, maxCol);
        for (let c = 0; c < renderCols; c++) {
            for (let r = 0; r < 6; r++) {
                let cell = document.createElement('div'); cell.className = 'big-road-cell';
                if (matrix[c] && matrix[c][r]) {
                    let val = matrix[c][r], circle = document.createElement('div');
                    circle.className = `circle circle-${val}`; circle.innerText = val; cell.appendChild(circle);
                }
                roadDiv.appendChild(cell);
            }
        }
        const wrapper = document.querySelector('.road-scroll-wrapper');
        if (wrapper) setTimeout(() => { wrapper.scrollLeft = (maxCol * 27) > wrapper.clientWidth ? (maxCol * 27) - wrapper.clientWidth + 50 : 0; }, 0);
    }

    function updateChart() {
        const ctx = document.getElementById('profitChart').getContext('2d');
        const pointRadii = state.graphData.map(val => val > 0 ? 3 : 0);
        if (!chartInstance) {
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: state.graphLabels, datasets: [{ label: 'Net Profit', data: state.graphData, borderColor: '#e67e22', backgroundColor: 'rgba(230, 126, 34, 0.1)', borderWidth: 2, fill: true, pointRadius: pointRadii, tension: 0.1 }] },
                options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 }, plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { grid: { color: '#f0f0f0' } } } }
            });
        } else {
            chartInstance.data.labels = state.graphLabels;
            chartInstance.data.datasets[0].data = state.graphData;
            chartInstance.data.datasets[0].borderColor = state.realBalance >= 0 ? '#27ae60' : '#c0392b';
            chartInstance.data.datasets[0].backgroundColor = state.realBalance >= 0 ? 'rgba(39, 174, 96, 0.1)' : 'rgba(192, 57, 43, 0.1)';
            chartInstance.data.datasets[0].pointRadius = pointRadii;
            chartInstance.update();
        }
    }

    function saveState() { undoStack.push(JSON.parse(JSON.stringify(state))); if (undoStack.length > 20) undoStack.shift(); }
    function undo() { if (undoStack.length === 0) return; state = undoStack.pop(); updateUI(); }
    function resetAll() { if(confirm("‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?")) location.reload(); }
    function softReset() {
        state.realBalance = 0; state.history = []; state.maxDrawdown = 0; state.maxBet = 0;
        state.highWaterMark = 0; state.targetReached = false; state.survivalActive = false;
        state.cycleStartBalance = 0;
        state.pStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 }; 
        state.bStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 };
        state.graphData = [0]; state.graphLabels = [0]; undoStack = [];
    }
    
    function showWinModal(isTrailing = false, profitVal = 0) { 
        if(!isAutoRunning) {
            let title = isTrailing ? "Profit Locked (Trailing)" : "Target Hit! (Cycle Reset)";
            let msg = isTrailing ? `Profit Locked` : `+${profitVal.toFixed(2)} Units`;
            
            document.getElementById('modal_title').innerText = title;
            document.getElementById('modal_profit_show').innerText = msg;
            document.getElementById('winModal').style.display = 'flex'; 
        }
    }
    function closeWinModal() { document.getElementById('winModal').style.display = 'none'; }
    function showRiskModal(reason) {
        document.getElementById('risk_reason').innerText = reason;
        document.getElementById('risk_dd').innerText = state.realBalance.toLocaleString(undefined, {minimumFractionDigits: 2});
        document.getElementById('riskModal').style.display = 'flex';
    }
    function closeRiskModal() { document.getElementById('riskModal').style.display = 'none'; }
    
    function runSimulation() {
        const n = parseInt(document.getElementById('sim_hands').value);
        saveState();
        for(let i=0; i<n; i++) processResult(Math.random() < 0.4932 ? 'P' : 'B', true);
        updateUI();
    }
    
    function toggleAutoSim() {
        if (isAutoRunning) return;
        isAutoRunning = true;
        document.getElementById('btn_auto_sim').style.display = 'none';
        document.getElementById('btn_stop_sim').style.display = 'inline-block';
        document.getElementById('sim_stats_display').style.display = 'block';
        if (simRoundCount === 0) { simRoundCount = 1; simSuccessCount = 0; softReset(); updateUI(); }
        let speed = parseInt(document.getElementById('sim_speed').value);
        if (speed === 0) runInstantLoop(); else autoPlayStep();
    }

    async function runInstantLoop() {
        const stopLoss = parseFloat(document.getElementById('stop_loss').value);
        const targetProfit = parseFloat(document.getElementById('target_profit').value);

        while(isAutoRunning) {
            let res = Math.random() < 0.4932 ? 'P' : 'B';
            processResult(res, true); 
            
            if (state.realBalance <= -stopLoss) { 
                stopAutoSim(); updateUI(); showRiskModal("Stop Loss Reached"); break; 
            }
            
            // Check Cycle Reset in Sim
            let cycleProfit = state.realBalance - state.cycleStartBalance;
            if (targetProfit > 0 && cycleProfit >= targetProfit) {
                simSuccessCount++; simRoundCount++; 
                softReset(); 
                if(simSuccessCount % 10 === 0) { updateUI(); await new Promise(r => setTimeout(r, 0)); }
            }
        }
    }

    function autoPlayStep() {
        if (!isAutoRunning) return;
        let speed = parseInt(document.getElementById('sim_speed').value);
        if (speed === 0) return; 
        
        processResult(Math.random() < 0.4932 ? 'P' : 'B', false);
        
        const stopLoss = parseFloat(document.getElementById('stop_loss').value);
        if (state.realBalance <= -stopLoss) { stopAutoSim(); showRiskModal("Stop Loss"); return; }
        
        if (document.getElementById('winModal').style.display === 'flex') {
             closeWinModal();
             simSuccessCount++; simRoundCount++; 
             updateUI();
        }
        
        autoTimer = setTimeout(autoPlayStep, speed);
    }

    function stopAutoSim() {
        isAutoRunning = false; clearTimeout(autoTimer);
        document.getElementById('btn_auto_sim').style.display = 'inline-block';
        document.getElementById('btn_stop_sim').style.display = 'none';
        updateUI();
    }

    window.onload = function() { restoreRecommended(); };
</script>
</body>
</html>




