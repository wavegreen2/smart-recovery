<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Baccarat AI: Ultimate Strategy (Trend/Bias Optimized)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #2c3e50; --accent: #e67e22; --player: #2980b9; --banker: #c0392b;
            --tie: #27ae60; --bg: #f4f6f7; --card-bg: #ffffff; --text: #2c3e50;
            --gray-light: #f8f9fa; --success: #27ae60; --warning: #f39c12; --danger: #c0392b; --auto: #8e44ad;
            --gold: #d4ac0d;
        }
        body { font-family: 'Segoe UI', 'Sarabun', sans-serif; background-color: var(--bg); color: var(--text); margin: 0; padding: 10px; display: flex; justify-content: center; height: 100vh; overflow: hidden; }
        .container { width: 100%; max-width: 1200px; display: grid; grid-template-columns: 340px 1fr; gap: 15px; height: 95vh; }
        .sidebar { background: var(--card-bg); padding: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); overflow-y: auto; display: flex; flex-direction: column; gap: 10px; height: 100%; border-top: 5px solid var(--gold); }
        .section-title { font-size: 0.85rem; font-weight: bold; color: var(--primary); margin-top: 5px; border-bottom: 2px solid #eee; padding-bottom: 3px; display: flex; justify-content: space-between; align-items: center; }
        .badge-ult { background: var(--gold); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.6rem; }
        .form-group { margin-bottom: 5px; }
        .form-group label { display: block; font-size: 0.8rem; font-weight: 600; margin-bottom: 2px; color: #555; }
        .form-group input, .form-group select { width: 100%; padding: 8px; border: 1px solid #bdc3c7; border-radius: 5px; font-size: 0.95rem; box-sizing: border-box; transition: all 0.2s; }
        .form-group input:focus, .form-group select:focus { border-color: var(--accent); outline: none; box-shadow: 0 0 0 2px rgba(230, 126, 34, 0.1); }
        .dynamic-config-box { background: #fffcf5; border: 1px solid #fae5d3; border-radius: 8px; padding: 8px; margin-bottom: 10px; display: none; }
        .dyn-header, .dyn-row { display: grid; grid-template-columns: 1fr 60px 60px; gap: 5px; align-items: center; }
        .dyn-header { font-size: 0.7rem; font-weight: bold; color: #d35400; margin-bottom: 5px; text-align: center; }
        .dyn-row { margin-bottom: 3px; }
        .dyn-label { font-size: 0.75rem; color: #34495e; font-weight: 600; }
        .dyn-input { width: 100%; padding: 4px; border: 1px solid #edbb99; border-radius: 4px; font-size: 0.85rem; text-align: center; background: white; }
        .btn-restore { background: white; border: 1px dashed var(--accent); color: var(--accent); font-size: 0.75rem; width: 100%; cursor: pointer; padding: 6px; margin-top: 5px; border-radius: 4px; font-weight: bold; }
        .btn-restore:hover { background: var(--accent); color: white; }
        .monitor-box { background: #2c3e50; border-radius: 8px; padding: 12px; margin-bottom: 5px; text-align: center; color: white; box-shadow: 0 4px 10px rgba(44, 62, 80, 0.2); }
        .monitor-label { font-size: 0.7rem; color: #bdc3c7; font-weight: 600; display: block; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 1px; }
        .monitor-val { font-size: 1.2rem; font-weight: bold; color: var(--gold); text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .status-done { color: #2c3e50; background-color: var(--gold); padding: 4px 12px; border-radius: 20px; display: inline-block; font-size: 0.9rem; margin-bottom: 5px; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .brain-monitor { background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .brain-col { text-align: center; }
        .brain-head { font-size: 0.7rem; font-weight: bold; margin-bottom: 2px; }
        .brain-val { font-size: 1.1rem; font-weight: 800; }
        .brain-info { font-size: 0.65rem; color: #7f8c8d; }
        .txt-p { color: var(--player); } .txt-b { color: var(--banker); }
        .btn-action { width: 100%; padding: 12px; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 0.9rem; margin-top: 5px; transition: transform 0.1s; }
        .btn-action:active { transform: scale(0.98); }
        .btn-sim { background: var(--primary); }
        .btn-auto { background: var(--auto); position: relative; overflow: hidden; }
        .btn-stop { background: var(--danger); display: none; }
        .btn-import { background: #7f8c8d; margin-top: 5px; }
        .btn-reset { background: #ecf0f1; color: #7f8c8d; border: 1px solid #bdc3c7; margin-top: 10px; }
        .btn-reset:hover { background: #bdc3c7; color: white; }
        .sim-stats { font-size: 0.75rem; color: #555; margin-top: 5px; text-align: center; background: #f4ecf7; padding: 5px; border-radius: 4px; border: 1px solid #e8daef; display: none; }
        .main-content { display: flex; flex-direction: column; gap: 15px; overflow-y: auto; padding-right: 5px; height: 100%; }
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; flex-shrink: 0; }
        .stat-card { background: var(--card-bg); padding: 10px; border-radius: 10px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.03); border-top: 4px solid transparent; }
        .stat-card.profit { border-top-color: var(--success); } .stat-card.loss { border-top-color: var(--danger); } .stat-card.pre { border-top-color: var(--gold); background: #fffcf5; }
        .stat-label { font-size: 0.65rem; color: #95a5a6; text-transform: uppercase; line-height: 1.2; }
        .stat-value { font-size: 1rem; font-weight: 800; margin-top: 3px; }
        .road-scroll-wrapper { background: var(--card-bg); padding: 10px; border-radius: 10px; box-shadow: inset 0 0 10px rgba(0,0,0,0.02); overflow-x: auto; overflow-y: hidden; height: 170px; min-height: 170px; flex-shrink: 0; width: 100%; box-sizing: border-box; scroll-behavior: smooth; }
        .big-road-grid { display: grid; grid-template-rows: repeat(6, 26px); grid-auto-columns: 26px; grid-auto-flow: column; gap: 1px; min-width: max-content; }
        .big-road-cell { width: 24px; height: 24px; display: flex; justify-content: center; align-items: center; font-size: 10px; font-weight: bold; border: 1px solid #f0f0f0; background: white; }
        .circle { width: 18px; height: 18px; border-radius: 50%; border: 2px solid transparent; display: flex; justify-content: center; align-items: center; background: transparent; }
        .circle-P { border-color: var(--player); color: var(--player); } .circle-B { border-color: var(--banker); color: var(--banker); } .circle-T { border-color: var(--tie); color: var(--tie); }
        .bet-panel { background: var(--card-bg); padding: 15px; border-radius: 12px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.08); flex-shrink: 0; border-bottom: 5px solid var(--primary); }
        .offset-formula { font-family: monospace; font-size: 0.9rem; color: #7f8c8d; background: #f0f3f4; padding: 4px 10px; border-radius: 4px; display: inline-block; margin-bottom: 10px; }
        .rec-amount { font-size: 3.5rem; font-weight: 900; line-height: 1; color: var(--primary); text-shadow: 2px 2px 0px #eee; }
        .rec-side { font-size: 1.8rem; font-weight: 800; margin-top: 5px; text-transform: uppercase; letter-spacing: 2px; }
        .side-p { color: var(--player); } .side-b { color: var(--banker); } .side-n { color: #95a5a6; }
        .controls { display: grid; grid-template-columns: 1fr 1fr 80px; gap: 10px; margin-top: 15px; }
        .btn-ctrl { padding: 15px; border: none; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; color: white; touch-action: manipulation; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.1s; }
        .btn-ctrl:active { transform: translateY(2px); }
        .btn-p { background: var(--player); } .btn-b { background: var(--banker); } .btn-u { background: #95a5a6; }
        .chart-box { background: var(--card-bg); padding: 10px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); flex-grow: 1; min-height: 250px; position: relative; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 999999; backdrop-filter: blur(5px); }
        .modal-box { background: white; padding: 30px 20px; border-radius: 15px; text-align: center; max-width: 400px; width: 85%; box-shadow: 0 20px 50px rgba(0,0,0,0.4); display: flex; flex-direction: column; align-items: center; border: 2px solid var(--gold); }
        .modal-icon { font-size: 4rem; margin-bottom: 15px; }
        .modal-text-th { font-size: 1.2rem; font-weight: bold; color: #2c3e50; margin-bottom: 5px; }
        .modal-sub { font-size: 1rem; color: var(--success); font-weight: bold; margin-bottom: 15px; }
        .btn-modal-ack { background: var(--success); color: white; border: none; padding: 12px 20px; width: 100%; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem; margin-top: 15px; }
        .risk-stat-box { background: #fdedec; border: 1px solid #fadbd8; padding: 10px; width: 100%; border-radius: 8px; margin-bottom: 15px; text-align: left; }
        .risk-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; }
        .risk-val { font-weight: bold; color: #c0392b; }
        
        @media (max-width: 768px) {
            body { overflow-y: auto; height: auto; display: block; }
            .container { grid-template-columns: 1fr; height: auto; display: flex; flex-direction: column; gap: 20px; padding-bottom: 30px; overflow: visible; }
            .sidebar { height: auto; margin-bottom: 0; flex-shrink: 0; }
            .main-content { height: auto; overflow: visible; }
            .road-scroll-wrapper { min-height: 170px; width: 100%; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .chart-box { min-height: 300px; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="sidebar">
        <div class="section-title">
            <span>‚öôÔ∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (Settings)</span>
            <span class="badge-ult">V7.0 ULTIMATE</span>
        </div>
        
        <div class="form-group">
            <label>‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå (Strategy Mode)</label>
            <select id="strat_mode" onchange="updateUI()">
                <option value="trend" selected>üêâ Follow Last (‡∏ï‡∏≤‡∏°‡∏°‡∏±‡∏á‡∏Å‡∏£) - Recommended</option>
                <option value="offset">‚öñÔ∏è Offset (‡∏™‡∏°‡∏î‡∏∏‡∏• P-B)</option>
            </select>
        </div>

        <div class="form-group">
            <label>‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô (Bankroll)</label>
            <input type="number" id="init_bank" value="1000000">
        </div>

        <div class="form-group">
            <label>‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏≥‡πÑ‡∏£/‡∏£‡∏≠‡∏ö (Target Units)</label>
            <input type="number" id="target_req" value="6">
            <div style="font-size:0.65rem; color:#27ae60; margin-top:2px;">*Python Log: 6 Units (Take Profit)</div>
        </div>
        
        <div class="form-group">
            <label>‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏á‡∏¥‡∏ô (Betting Strategy)</label>
            <select id="divisor_mode" onchange="toggleDivisorInput()">
                <option value="dynamic" selected>üåä Dynamic (Optimized)</option>
                <option value="fixed">üîí Fixed (‡∏ï‡∏±‡∏ß‡∏´‡∏≤‡∏£‡∏Ñ‡∏á‡∏ó‡∏µ‡πà)</option>
            </select>
        </div>

        <div class="form-group" id="fixed_divisor_group">
            <label>Divisor (‡∏ï‡∏±‡∏ß‡∏´‡∏≤‡∏£‡∏Ñ‡∏á‡∏ó‡∏µ‡πà)</label>
            <input type="number" id="divisor_val" value="3.0" step="0.01">
        </div>

        <div id="dynamic_config_group" class="dynamic-config-box">
            <div class="form-group" style="margin-bottom: 8px;">
                <label style="font-size: 0.8rem; color: #d35400; font-weight:bold;">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Level (Steps)</label>
                <select id="level_count" onchange="renderDynamicInputs()" style="padding: 6px; font-size: 0.9rem; width:100%; background:white; border:1px solid #edbb99;">
                    <option value="20" selected>20 Levels (Max Safety)</option>
                    <option value="16">16 Levels (Standard)</option>
                </select>
            </div>
            
            <div class="form-group" style="margin-bottom: 8px; background: #fff; padding: 5px; border-radius: 4px; border: 1px solid #edbb99;">
                <label style="color:var(--accent); font-weight:bold;">Recovery Factor</label>
                <input type="number" id="recovery_factor" value="0.9451" step="0.0001" style="border:none; background:transparent; font-weight:bold; color:var(--accent); font-size:1rem;">
            </div>

            <div class="form-group" style="margin-bottom: 8px; background: #fff; padding: 5px; border-radius: 4px; border: 1px solid #edbb99;">
                <label style="color:var(--warning); font-weight:bold;">Divisor Decay</label>
                <input type="number" id="div_decay" value="1.0439" step="0.0001" style="border:none; background:transparent; font-weight:bold; color:var(--warning); font-size:1rem;">
            </div>

            <div class="dyn-header">
                <span>Level</span>
                <span>< Units</span>
                <span>Divisor</span>
            </div>
            <div id="dyn_rows_container"></div>
            <button class="btn-restore" onclick="restoreRecommended()">‚Ü∫ ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ Ultimate (Python Log)</button>
        </div>

        <div class="form-group">
            <label>‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (Min Bet / Unit)</label>
            <input type="number" id="min_bet" value="1">
        </div>
        <div class="form-group">
            <label>‡∏ä‡∏¥‡∏õ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (Chip Size)</label>
            <input type="number" id="chip_size" value="1">
        </div>
        
        <div class="form-group">
            <label style="color:var(--danger);">‚öñÔ∏è ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á (Loss Balance)</label>
            <select id="balance_mode">
                <option value="0.4652" selected>üèÜ Aggressive Player (Bias 2)</option>
                <option value="0.5">ü§ù 50% (‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô)</option>
                <option value="1">üö´ ‡∏õ‡∏¥‡∏î (‡πÅ‡∏¢‡∏Å‡∏≠‡∏¥‡∏™‡∏£‡∏∞)</option>
            </select>
            <div style="font-size:0.65rem; color:#888; margin-top:2px;">*Bias Mode: ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏Å‡∏•‡∏µ‡πà‡∏¢‡πÑ‡∏°‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ù‡∏±‡πà‡∏á‡πÉ‡∏î‡∏ù‡∏±‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏ô‡∏±‡∏Å</div>
        </div>

        <div class="section-title">üéØ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ (Status)</div>
        <div class="monitor-box">
            <span class="monitor-label">‡∏Å‡∏≥‡πÑ‡∏£‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô / ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢</span>
            <div id="target_status_display" class="monitor-val">0 / 6</div>
            <div style="font-size:0.6rem; color:#bdc3c7; margin-top:4px;">Stop Loss Ref: 4,698 Units</div>
        </div>

        <div class="section-title">üß† AI Brain Monitor</div>
        <div class="brain-monitor">
            <div class="brain-col">
                <div class="brain-head txt-p">PLAYER AI</div>
                <div class="brain-val txt-p" id="mon_p_req">0</div>
                <div class="brain-info" id="mon_p_info">Wait: 0</div>
            </div>
            <div class="brain-col">
                <div class="brain-head txt-b">BANKER AI</div>
                <div class="brain-val txt-b" id="mon_b_req">0</div>
                <div class="brain-info" id="mon_b_info">Wait: 0</div>
            </div>
        </div>

        <button class="btn-reset" onclick="resetAll()">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (Hard Reset)</button>

        <div class="section-title">üß™ ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠ (Tools)</div>
        <div class="form-group">
            <input type="number" id="sim_hands" value="1" placeholder="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡∏≤ (Hands)">
            <button class="btn-action btn-sim" onclick="runSimulation()">‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Simulate)</button>
            <label style="margin-top:10px;">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß Auto Sim:</label>
            <select id="sim_speed" style="margin-bottom:5px;">
                <option value="0" selected>üöÄ ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (Instant)</option>
                <option value="100">‚ö° ‡πÄ‡∏£‡πá‡∏ß (Fast)</option>
            </select>
            <button class="btn-action btn-auto" id="btn_auto_sim" onclick="toggleAutoSim()">üöÄ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á (Auto Sim)</button>
            <button class="btn-action btn-stop" id="btn_stop_sim" onclick="stopAutoSim()">‚èπ ‡∏´‡∏¢‡∏∏‡∏î (STOP)</button>
            <div id="sim_stats_display" class="sim-stats">
                ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà (Round): <span id="sim_round_count">0</span><br>
                ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: <span id="sim_success_count" style="color:green; font-weight:bold;">0</span>
            </div>
            <button class="btn-action btn-import" onclick="importLogs()">üì• ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Import Logs)</button>
        </div>
    </div>

    <div class="main-content">
        <div class="stats-grid">
            <div class="stat-card profit">
                <div class="stat-label">‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ (Net Profit)</div>
                <div class="stat-value" id="disp_net">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Max Drawdown</div>
                <div class="stat-value" id="disp_dd">0</div>
            </div>
            <div class="stat-card loss">
                <div class="stat-label">Max Bet (Real)</div>
                <div class="stat-value" id="disp_maxbet">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏∑‡∏≠ (Hands)</div>
                <div class="stat-value" id="disp_hands">0</div>
            </div>
            <div class="stat-card pre">
                <div class="stat-label">DD ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏õ‡πâ‡∏≤<br>(Pre-Target DD)</div>
                <div class="stat-value" id="disp_dd_pre">0</div>
            </div>
            <div class="stat-card pre">
                <div class="stat-label">MaxBet ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏õ‡πâ‡∏≤<br>(Pre-Target MaxBet)</div>
                <div class="stat-value" id="disp_bet_pre">0</div>
            </div>
        </div>

        <div class="road-scroll-wrapper">
            <div class="big-road-grid" id="road_container"></div>
        </div>

        <div class="bet-panel">
            <div class="offset-formula" id="formula_disp">Strategy: Follow Last</div>
            <div class="rec-amount" id="rec_amount">0</div>
            <div class="rec-side side-n" id="rec_side">WAIT</div>
            <div class="controls">
                <button class="btn-ctrl btn-p" onclick="processResult('P')">PLAYER</button>
                <button class="btn-ctrl btn-b" onclick="processResult('B')">BANKER</button>
                <button class="btn-ctrl btn-u" onclick="undo()">UNDO</button>
            </div>
        </div>
        <div class="chart-box">
            <canvas id="profitChart"></canvas>
        </div>
    </div>
</div>

<div class="modal-overlay" id="winModal">
    <div class="modal-box">
        <div class="modal-icon">üéâ</div>
        <div class="modal-text-th">‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (Target Hit)</div>
        <div class="modal-sub" id="modal_profit_show">+6 Units</div>
        <div class="modal-text-th" style="font-size:0.9rem; color:#7f8c8d;">Ultimate Strategy Validated</div>
        <button class="btn-modal-ack" onclick="closeWinModal()">‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö (Acknowledge)</button>
    </div>
</div>

<div class="modal-overlay" id="riskModal">
    <div class="modal-box" style="border-top: 5px solid #c0392b;">
        <div class="modal-icon">‚ö†Ô∏è</div>
        <div class="modal-text-th" style="color:#c0392b;">Stop Loss Reached</div>
        <div class="risk-stat-box">
            <div class="risk-row"><span>Drawdown:</span><span class="risk-val" id="risk_dd">-</span></div>
            <div class="risk-row"><span>Max Bet:</span><span class="risk-val" id="risk_maxbet">-</span></div>
        </div>
        <button class="btn-modal-ack" style="background:#c0392b;" onclick="closeRiskModal()">‡∏õ‡∏¥‡∏î (Close)</button>
    </div>
</div>

<script>
    let state = { realBalance: 0, history: [], maxDrawdown: 0, maxBet: 0, firstTargetHit: false, preTargetDD: 0, preTargetMaxBet: 0, targetReached: false, pStrat: { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 }, bStrat: { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 }, graphData: [0], graphLabels: [0] };
    let undoStack = [];
    let chartInstance = null;
    let isAutoRunning = false;
    let simRoundCount = 0;
    let simSuccessCount = 0;
    let autoTimer = null; 

    function toggleDivisorInput() {
        const mode = document.getElementById('divisor_mode').value;
        document.getElementById('fixed_divisor_group').style.display = (mode === 'fixed') ? 'block' : 'none';
        document.getElementById('dynamic_config_group').style.display = (mode === 'dynamic') ? 'block' : 'none';
        if (mode === 'dynamic') {
            const container = document.getElementById('dyn_rows_container');
            if (container.innerHTML.trim() === '') renderDynamicInputs();
        }
        updateUI();
    }

    function renderDynamicInputs() {
        const count = parseInt(document.getElementById('level_count').value);
        const container = document.getElementById('dyn_rows_container');
        // Presets optimized for deep drawdown recovery (matches -34k worst case resilience)
        const presets = [
            { th: 60, div: 4.4341 }, { th: 100, div: 3.5 }, { th: 200, div: 3.0 }, { th: 300, div: 2.8 },
            { th: 500, div: 2.5 }, { th: 800, div: 2.4 }, { th: 1200, div: 2.3 }, { th: 1800, div: 2.2 },
            { th: 2500, div: 2.1 }, { th: 3500, div: 2.05 }, { th: 4698, div: 2.01 }, { th: 6000, div: 2.0 },
            { th: 8000, div: 1.95 }, { th: 10000, div: 1.9 }, { th: 15000, div: 1.8 }, { th: 99999, div: 1.5 }
        ];
        let html = '';
        for (let i = 1; i <= count; i++) {
            let defaultTh = (i <= presets.length) ? presets[i-1].th : i * 500;
            let defaultDiv = (i <= presets.length) ? presets[i-1].div : 2.0;
            html += `<div class="dyn-row"><span class="dyn-label">Level ${i}</span><input type="number" id="th_${i}" value="${defaultTh}" class="dyn-input"><input type="number" id="div_${i}" value="${defaultDiv}" class="dyn-input"></div>`;
        }
        container.innerHTML = html;
    }

    function restoreRecommended() {
        // Values from Python Log "Best Ultimate Configuration"
        document.getElementById('init_bank').value = 1000000;
        document.getElementById('target_req').value = 6;
        document.getElementById('strat_mode').value = "trend";
        document.getElementById('level_count').value = 20;
        document.getElementById('recovery_factor').value = 0.9451; 
        document.getElementById('div_decay').value = 1.0439;
        document.getElementById('balance_mode').value = "0.4652"; // Bias 2 equivalent
        renderDynamicInputs();
        updateUI();
    }

    function calculateDivisor(deficit, minBet) {
        const mode = document.getElementById('divisor_mode').value;
        if (mode === 'fixed') return parseFloat(document.getElementById('divisor_val').value);
        let unitsDown = deficit / minBet;
        const levelCount = parseInt(document.getElementById('level_count').value);
        for (let i = 1; i <= levelCount; i++) {
            let thElem = document.getElementById(`th_${i}`);
            let divElem = document.getElementById(`div_${i}`);
            if (thElem && divElem) {
                if (unitsDown < parseFloat(thElem.value)) return parseFloat(divElem.value);
            }
        }
        let lastDivElem = document.getElementById(`div_${levelCount}`);
        return lastDivElem ? parseFloat(lastDivElem.value) : 2.0;
    }

    function getRawBet(strat, side) {
        const minBet = parseFloat(document.getElementById('min_bet').value);
        const chip = parseFloat(document.getElementById('chip_size').value);
        const recoveryFactor = parseFloat(document.getElementById('recovery_factor').value) || 1.0;
        const decay = parseFloat(document.getElementById('div_decay').value) || 1.0;
        let bet = 0, currentDivisor = 0;

        if (strat.stage >= 1) {
            let multiplier = Math.pow(2, strat.stage);
            bet = strat.initBet * multiplier;
            if (chip > 0) bet = Math.ceil(bet / chip) * chip;
        } else if (strat.wait >= 1) {
            let deficit = Math.abs(strat.bal);
            if (deficit > 0) {
                let rawDivisor = calculateDivisor(deficit, minBet);
                let decayedDivisor = rawDivisor * Math.pow(decay, (strat.cons_loss || 0));
                let adjustedDivisor = (side === 'B') ? (decayedDivisor * 0.95) : decayedDivisor;
                let needed = (deficit * recoveryFactor) + minBet; 
                let raw = Math.ceil(needed / adjustedDivisor);
                if (chip > 0) raw = Math.ceil(raw / chip) * chip;
                if (raw < minBet) raw = minBet;
                bet = raw;
                currentDivisor = decayedDivisor; 
            } else {
                bet = minBet;
            }
        }
        return { bet: bet, divisor: currentDivisor };
    }

    function updateAI(strat, side, isPWin, rawBet) {
        const isWin = (side === 'P' && isPWin) || (side === 'B' && !isPWin);
        if (isWin) {
            strat.wait++;
            strat.cons_loss = 0;
            let profit = (side === 'P') ? rawBet : (rawBet * 0.95);
            strat.bal += profit;
            if (rawBet > 0) {
                if (strat.stage === 0) { strat.initBet = rawBet; strat.stage = 1; } else { strat.stage++; }
            }
        } else {
            strat.wait = 0;
            strat.cons_loss = (strat.cons_loss || 0) + 1;
            if (rawBet > 0) { strat.bal -= rawBet; strat.stage = 0; }
        }
    }

    function applyLossBalancing() {
        const mode = document.getElementById('balance_mode').value;
        if (mode === "1") return; 
        let p = state.pStrat.bal, b = state.bStrat.bal;
        if (p + b >= 0) return;
        let total = p + b;
        let ratio = parseFloat(mode); 
        if (p < b) { state.pStrat.bal = total * ratio; state.bStrat.bal = total * (1 - ratio); }
        else { state.bStrat.bal = total * ratio; state.pStrat.bal = total * (1 - ratio); }
    }

    function processResult(res, isSim = false) {
        if (!isSim) saveState();
        const isPWin = (res === 'P');
        const unit = parseFloat(document.getElementById('min_bet').value);
        const chip = parseFloat(document.getElementById('chip_size').value);
        const targetReq = parseFloat(document.getElementById('target_req').value);
        const stratMode = document.getElementById('strat_mode').value;

        // Calculate AI Bets
        const pObj = getRawBet(state.pStrat, 'P');
        const bObj = getRawBet(state.bStrat, 'B');
        const rawP = pObj.bet, rawB = bObj.bet;

        // Strategy Logic
        let netBet = 0, netSide = null;

        if (stratMode === 'offset') {
            if (rawP > rawB) { netBet = rawP - rawB; netSide = 'P'; } 
            else if (rawB > rawP) { netBet = rawB - rawP; netSide = 'B'; }
        } else {
            // Trend Follow Last
            let lastRes = state.history.length > 0 ? state.history[state.history.length - 1] : null;
            let trendSide = lastRes || 'P'; // Default to P (Bias 2) if no history
            
            // Use the bet amount from the losing side of the AI (Recovery) or Base
            // Simply use the AI calculation for the side we want to bet on
            let aiBet = (trendSide === 'P') ? rawP : rawB;
            
            // If AI says 0 (Wait), force min bet for Trend Following? No, respect AI wait.
            // But AI waits only after win.
            // Let's use max(rawP, rawB) as the "System Bet Amount" applied to the Trend Side
            let systemBet = Math.max(rawP, rawB);
            
            netSide = trendSide;
            netBet = systemBet;
        }

        // Cap at Target
        const reductionCap = targetReq + 0.01; 
        let gap = reductionCap - state.realBalance;
        if (gap > 0 && netBet > 0) {
            let maxAllowed = (netSide === 'P') ? gap : (gap / 0.95);
            if (netBet > maxAllowed) {
                netBet = maxAllowed;
                if (chip > 0) netBet = Math.ceil(netBet / chip) * chip;
                if (netBet < unit) netBet = unit; 
            }
        }

        if (!state.firstTargetHit && netBet > 0) {
            if (netBet > state.preTargetMaxBet) state.preTargetMaxBet = netBet;
        }

        if (netBet > 0) {
            if (netSide === 'P') state.realBalance += isPWin ? netBet : -netBet;
            else state.realBalance += !isPWin ? (netBet * 0.95) : -netBet;
        }

        // Update AI Internal State (Always runs in background)
        updateAI(state.pStrat, 'P', isPWin, rawP);
        updateAI(state.bStrat, 'B', isPWin, rawB);
        applyLossBalancing();

        state.history.push(res);
        state.graphData.push(state.realBalance);
        state.graphLabels.push(state.history.length);
        
        if (state.realBalance < state.maxDrawdown) state.maxDrawdown = state.realBalance;
        if (netBet > state.maxBet) state.maxBet = netBet;

        let winTarget = targetReq;
        if (!state.firstTargetHit) {
            if (state.realBalance < state.preTargetDD) state.preTargetDD = state.realBalance;
            if (state.realBalance >= winTarget) state.firstTargetHit = true;
        }

        let roundedBal = Math.round(state.realBalance * 100) / 100;
        if (!isSim && roundedBal >= winTarget && !state.targetReached) {
            showWinModal();
            state.targetReached = true; 
        }
        if (roundedBal < winTarget) state.targetReached = false;
        if (!isSim) updateUI();
    }

    function updateUI() {
        const unit = parseFloat(document.getElementById('min_bet').value);
        const chip = parseFloat(document.getElementById('chip_size').value);
        const targetReq = parseFloat(document.getElementById('target_req').value);
        const stratMode = document.getElementById('strat_mode').value;

        const pObj = getRawBet(state.pStrat, 'P');
        const bObj = getRawBet(state.bStrat, 'B');
        const nextP = pObj.bet, nextB = bObj.bet;
        
        let netAmt = 0, netSide = "WAIT", formula = "", sideClass = "side-n";

        if (stratMode === 'offset') {
            if (nextP > nextB) { netAmt = nextP - nextB; netSide = "PLAYER"; formula = `Offset: P(${nextP}) - B(${nextB})`; sideClass = "side-p"; }
            else if (nextB > nextP) { netAmt = nextB - nextP; netSide = "BANKER"; formula = `Offset: B(${nextB}) - P(${nextP})`; sideClass = "side-b"; }
            else formula = "Offset Balanced (Wait)";
        } else {
            // Trend Mode
            let lastRes = state.history.length > 0 ? state.history[state.history.length - 1] : null;
            let trendSide = lastRes === 'B' ? 'BANKER' : 'PLAYER'; // Default P
            let systemBet = Math.max(nextP, nextB);
            
            netSide = trendSide;
            netAmt = systemBet;
            sideClass = trendSide === 'PLAYER' ? 'side-p' : 'side-b';
            formula = `Trend: Follow ${lastRes || 'Start(P)'} | Base: ${systemBet}`;
        }

        // Target Cap Display
        const reductionCap = targetReq + 0.01; 
        let gap = reductionCap - state.realBalance;
        if (gap > 0 && netAmt > 0) {
            let maxAllowed = (netSide === 'PLAYER' || netSide === 'P') ? gap : (gap / 0.95);
            if (netAmt > maxAllowed) {
                netAmt = maxAllowed;
                if (chip > 0) netAmt = Math.ceil(netAmt / chip) * chip;
                if (netAmt < unit) netAmt = unit;
            }
        }

        document.getElementById('rec_amount').innerText = netAmt.toLocaleString();
        document.getElementById('rec_side').innerText = netSide;
        document.getElementById('rec_side').className = `rec-side ${sideClass}`;
        document.getElementById('formula_disp').innerText = formula;

        document.getElementById('mon_p_req').innerText = Math.round(state.pStrat.bal).toLocaleString();
        document.getElementById('mon_b_req').innerText = Math.round(state.bStrat.bal).toLocaleString();
        document.getElementById('mon_p_info').innerText = `Wait:${state.pStrat.wait} | Stg:${state.pStrat.stage}`;
        document.getElementById('mon_b_info').innerText = `Wait:${state.bStrat.wait} | Stg:${state.bStrat.stage}`;

        const statusElem = document.getElementById('target_status_display');
        statusElem.innerText = `${state.realBalance.toFixed(2)} / ${targetReq}`;
        if (state.firstTargetHit) statusElem.innerHTML += " <span class='status-done'>DONE</span>";

        const profitElem = document.getElementById('disp_net');
        profitElem.innerText = state.realBalance.toLocaleString(undefined, {minimumFractionDigits: 2});
        profitElem.style.color = state.realBalance >= 0 ? 'var(--success)' : 'var(--danger)';

        document.getElementById('disp_dd').innerText = state.maxDrawdown.toLocaleString(undefined, {minimumFractionDigits: 2});
        document.getElementById('disp_maxbet').innerText = state.maxBet.toLocaleString();
        document.getElementById('disp_hands').innerText = state.history.length;
        document.getElementById('disp_dd_pre').innerText = state.preTargetDD.toLocaleString(undefined, {minimumFractionDigits: 2});
        document.getElementById('disp_bet_pre').innerText = state.preTargetMaxBet.toLocaleString();
        document.getElementById('sim_round_count').innerText = simRoundCount;
        document.getElementById('sim_success_count').innerText = simSuccessCount;

        renderBigRoad();
        updateChart();
    }

    function renderBigRoad() {
        const roadDiv = document.getElementById('road_container');
        roadDiv.innerHTML = '';
        let matrix = [], col = 0, row = 0, lastWinner = null;
        const setCell = (c, r, val) => { if (!matrix[c]) matrix[c] = []; matrix[c][r] = val; };
        state.history.forEach(res => {
            if (lastWinner === null) { setCell(col, row, res); lastWinner = res; }
            else {
                if (res === lastWinner) {
                    if (row < 5 && (!matrix[col] || matrix[col][row+1] === undefined)) row++; else col++;
                    setCell(col, row, res);
                } else { col++; row = 0; setCell(col, row, res); lastWinner = res; }
            }
        });
        const maxCol = matrix.length, renderCols = Math.max(20, maxCol);
        for (let c = 0; c < renderCols; c++) {
            for (let r = 0; r < 6; r++) {
                let cell = document.createElement('div'); cell.className = 'big-road-cell';
                if (matrix[c] && matrix[c][r]) {
                    let val = matrix[c][r], circle = document.createElement('div');
                    circle.className = `circle circle-${val}`; circle.innerText = val; cell.appendChild(circle);
                }
                roadDiv.appendChild(cell);
            }
        }
        const wrapper = document.querySelector('.road-scroll-wrapper');
        if (wrapper) setTimeout(() => { wrapper.scrollLeft = (maxCol * 27) > wrapper.clientWidth ? (maxCol * 27) - wrapper.clientWidth + 50 : 0; }, 0);
    }

    function updateChart() {
        const ctx = document.getElementById('profitChart').getContext('2d');
        const pointRadii = state.graphData.map(val => val > 0 ? 3 : 0);
        if (!chartInstance) {
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: state.graphLabels, datasets: [{ label: 'Net Profit', data: state.graphData, borderColor: '#e67e22', backgroundColor: 'rgba(230, 126, 34, 0.1)', borderWidth: 2, fill: true, pointRadius: pointRadii, tension: 0.1 }] },
                options: { responsive: true, maintainAspectRatio: false, animation: { duration: 0 }, plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { grid: { color: '#f0f0f0' } } } }
            });
        } else {
            chartInstance.data.labels = state.graphLabels;
            chartInstance.data.datasets[0].data = state.graphData;
            chartInstance.data.datasets[0].borderColor = state.realBalance >= 0 ? '#27ae60' : '#c0392b';
            chartInstance.data.datasets[0].backgroundColor = state.realBalance >= 0 ? 'rgba(39, 174, 96, 0.1)' : 'rgba(192, 57, 43, 0.1)';
            chartInstance.data.datasets[0].pointRadius = pointRadii;
            chartInstance.update();
        }
    }

    function saveState() { undoStack.push(JSON.parse(JSON.stringify(state))); if (undoStack.length > 20) undoStack.shift(); }
    function undo() { if (undoStack.length === 0) return; state = undoStack.pop(); updateUI(); }
    function resetAll() { if(confirm("‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? (Hard Reset)")) location.reload(); }
    function softReset() {
        state.realBalance = 0; state.history = []; state.maxDrawdown = 0; state.maxBet = 0;
        state.firstTargetHit = false; state.preTargetDD = 0; state.preTargetMaxBet = 0; state.targetReached = false;
        state.pStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 }; state.bStrat = { bal: 0, wait: 0, stage: 0, initBet: 0, cons_loss: 0 };
        state.graphData = [0]; state.graphLabels = [0]; undoStack = [];
    }
    function showWinModal() { if(!isAutoRunning) document.getElementById('winModal').style.display = 'flex'; }
    function closeWinModal() { document.getElementById('winModal').style.display = 'none'; }
    function showRiskModal() {
        document.getElementById('risk_dd').innerText = state.preTargetDD.toLocaleString(undefined, {minimumFractionDigits: 2});
        document.getElementById('risk_maxbet').innerText = state.preTargetMaxBet.toLocaleString();
        document.getElementById('riskModal').style.display = 'flex';
    }
    function closeRiskModal() { document.getElementById('riskModal').style.display = 'none'; }
    function runSimulation() {
        const n = parseInt(document.getElementById('sim_hands').value);
        saveState();
        const unit = parseFloat(document.getElementById('min_bet').value);
        const targetReq = parseFloat(document.getElementById('target_req').value);
        for(let i=0; i<n; i++) processResult(Math.random() < 0.4932 ? 'P' : 'B', true);
        updateUI();
        if (state.realBalance >= targetReq) { showWinModal(); state.targetReached = true; }
    }
    function toggleAutoSim() {
        if (isAutoRunning) return;
        isAutoRunning = true;
        document.getElementById('btn_auto_sim').style.display = 'none';
        document.getElementById('btn_stop_sim').style.display = 'inline-block';
        document.getElementById('sim_stats_display').style.display = 'block';
        if (simRoundCount === 0) { simRoundCount = 1; simSuccessCount = 0; softReset(); updateUI(); }
        let speed = parseInt(document.getElementById('sim_speed').value);
        if (speed === 0) runInstantLoop(); else autoPlayStep();
    }
    async function runInstantLoop() {
        const unit = parseFloat(document.getElementById('min_bet').value);
        const targetReq = parseFloat(document.getElementById('target_req').value);
        const STOP_THRESHOLD = 4698; // From Python Log
        while(isAutoRunning) {
            let res = Math.random() < 0.4932 ? 'P' : 'B';
            processResult(res, true); 
            if (state.realBalance <= -STOP_THRESHOLD) { stopAutoSim(); updateUI(); showRiskModal(); break; }
            if (state.realBalance >= targetReq) {
                simSuccessCount++; simRoundCount++; softReset();
                if(simSuccessCount % 10 === 0) { updateUI(); await new Promise(r => setTimeout(r, 0)); }
            }
        }
    }
    function autoPlayStep() {
        if (!isAutoRunning) return;
        let speed = parseInt(document.getElementById('sim_speed').value);
        if (speed === 0) return; 
        processResult(Math.random() < 0.4932 ? 'P' : 'B', false);
        const unit = parseFloat(document.getElementById('min_bet').value);
        const targetReq = parseFloat(document.getElementById('target_req').value);
        const STOP_THRESHOLD = 4698;
        if (state.realBalance <= -STOP_THRESHOLD) { stopAutoSim(); showRiskModal(); return; }
        if (state.targetReached) { simSuccessCount++; simRoundCount++; softReset(); updateUI(); closeWinModal(); }
        autoTimer = setTimeout(autoPlayStep, speed);
    }
    function stopAutoSim() {
        isAutoRunning = false; clearTimeout(autoTimer);
        document.getElementById('btn_auto_sim').style.display = 'inline-block';
        document.getElementById('btn_stop_sim').style.display = 'none';
        updateUI();
    }
    function importLogs() {
        let input = prompt("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡πÄ‡∏ä‡πà‡∏ô PPBBPB...):");
        if (input) {
            let clean = input.toUpperCase().replace(/[^PBT]/g, '');
            if (clean.length > 0) {
                saveState();
                const unit = parseFloat(document.getElementById('min_bet').value);
                const targetReq = parseFloat(document.getElementById('target_req').value);
                clean.split('').forEach(c => processResult(c, true));
                updateUI();
                if (state.realBalance >= targetReq) { showWinModal(); state.targetReached = true; }
                alert(`‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢ ${clean.length} ‡∏ï‡∏≤`);
            } else alert("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (P, B, T)");
        }
    }
    window.onload = function() { toggleDivisorInput(); renderDynamicInputs(); updateUI(); };
</script>
</body>
</html>
