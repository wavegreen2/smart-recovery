<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Baccarat AI: Ultimate V3.6 ‚Äî 3 Modes (LEGACY + KCAP_A + KCAP_B) + Shared Signal</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      --primary:#2c3e50;--accent:#e74c3c;--player:#2980b9;--banker:#c0392b;--tie:#27ae60;
      --bg:#f4f6f7;--card-bg:#fff;--text:#2c3e50;--success:#27ae60;--warning:#f39c12;--danger:#c0392b;
      --auto:#8e44ad;--gold:#d4ac0d;--target:#16a085;--comm:#8e44ad;
      --kcapA:#8e44ad; /* purple */
      --kcapB:#e67e22; /* orange */
    }
    *{box-sizing:border-box}
    body{font-family:'Segoe UI','Sarabun',sans-serif;background:var(--bg);color:var(--text);margin:0;padding:10px;display:flex;justify-content:center;height:100vh;overflow:hidden}
    .container{width:100%;max-width:1200px;display:grid;grid-template-columns:360px 1fr;gap:15px;height:95vh}
    .sidebar{background:var(--card-bg);padding:15px;border-radius:12px;box-shadow:0 4px 15px rgba(0,0,0,.05);overflow-y:auto;display:flex;flex-direction:column;gap:10px;height:100%;border-top:5px solid var(--target)}
    .main-content{display:flex;flex-direction:column;gap:15px;overflow-y:auto;padding-right:5px;height:100%}
    .section-title{font-size:.85rem;font-weight:bold;color:var(--primary);margin-top:5px;border-bottom:2px solid #eee;padding-bottom:3px;display:flex;justify-content:space-between;align-items:center}
    .badge-ult{background:var(--primary);color:#fff;padding:2px 6px;border-radius:4px;font-size:.6rem}
    .form-group{margin-bottom:5px}
    .form-group label{display:block;font-size:.8rem;font-weight:600;margin-bottom:2px;color:#555}
    .form-group input,.form-group select{width:100%;padding:8px;border:1px solid #bdc3c7;border-radius:5px;font-size:.95rem}
    .btn-action{width:100%;padding:12px;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;font-size:.9rem;margin-top:5px}
    .btn-sim{background:var(--primary)}
    .btn-auto{background:var(--auto)}
    .btn-stop{background:var(--danger);display:none}
    .btn-reset{background:#ecf0f1;color:#7f8c8d;border:1px solid #bdc3c7;margin-top:10px;width:100%;padding:12px;border-radius:6px;cursor:pointer;font-weight:bold;font-size:.9rem}
    .btn-restore{background:#fff;border:1px dashed var(--target);color:var(--target);font-size:.75rem;width:100%;cursor:pointer;padding:6px;margin-top:5px;border-radius:4px;font-weight:bold}
    .target-box{background:#e8f8f5;border:1px solid #a3e4d7;border-radius:8px;padding:8px;margin-bottom:5px}
    .target-title{font-size:.75rem;font-weight:bold;color:var(--target);margin-bottom:5px}
    .feature-box{background:#fffcf5;border:1px solid #fae5d3;border-radius:8px;padding:8px;margin-bottom:5px}
    .feature-title{font-size:.75rem;font-weight:bold;color:#d35400;margin-bottom:5px;display:flex;justify-content:space-between;align-items:center}
    .dual-input{display:grid;grid-template-columns:1fr 1fr;gap:5px}
    .survival-active{animation:pulse-red 2s infinite;border:2px solid var(--danger)}
    @keyframes pulse-red{0%,100%{box-shadow:0 0 5px rgba(192,57,43,.3)}50%{box-shadow:0 0 15px rgba(192,57,43,.6)}}

    .comm-box{background:#f5eef8;border:1px solid #d2b4de;border-radius:8px;padding:8px;margin-bottom:5px}
    .comm-title{font-size:.75rem;font-weight:bold;color:var(--comm);margin-bottom:5px;display:flex;justify-content:space-between;align-items:center}
    .btn-guide{background:var(--comm);color:#fff;border:none;padding:3px 8px;border-radius:4px;font-size:.65rem;cursor:pointer;font-weight:800}
    .comm-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px}
    .comm-stat{background:rgba(142,68,173,.08);border-radius:6px;padding:6px;text-align:center}
    .comm-stat .lb{font-size:.6rem;color:#7f8c8d;text-transform:uppercase}
    .comm-stat .vl{font-size:.95rem;font-weight:900;color:var(--comm)}

    .monitor-box{background:#2c3e50;border-radius:8px;padding:12px;margin-bottom:5px;text-align:center;color:#fff}
    .monitor-label{font-size:.7rem;color:#bdc3c7;font-weight:600;display:block;margin-bottom:2px;text-transform:uppercase;letter-spacing:1px}
    .monitor-val{font-size:1.2rem;font-weight:bold;color:var(--gold)}
    .cycle-monitor{display:flex;justify-content:space-between;background:rgba(0,0,0,.2);padding:5px 10px;border-radius:4px;margin-top:5px;font-size:.8rem}

    .brain-monitor{background:#fff;border:1px solid #e0e0e0;border-radius:8px;padding:8px;display:grid;grid-template-columns:1fr 1fr;gap:5px}
    .brain-col{text-align:center}
    .brain-head{font-size:.7rem;font-weight:bold;margin-bottom:2px}
    .brain-val{font-size:1.1rem;font-weight:800}
    .brain-info{font-size:.65rem;color:#7f8c8d}
    .txt-p{color:var(--player)} .txt-b{color:var(--banker)}

    .stats-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;flex-shrink:0}
    .stat-card{background:var(--card-bg);padding:10px;border-radius:10px;text-align:center;box-shadow:0 2px 10px rgba(0,0,0,.03);border-top:4px solid transparent}
    .stat-card.profit{border-top-color:var(--success)}
    .stat-card.loss{border-top-color:var(--danger)}
    .stat-card.pre{border-top-color:var(--gold);background:#fffcf5}
    .stat-card.comm{border-top-color:var(--comm);background:#f9f0ff}
    .stat-label{font-size:.65rem;color:#95a5a6;text-transform:uppercase;line-height:1.2}
    .stat-value{font-size:1rem;font-weight:800;margin-top:3px}

    .road-scroll-wrapper{background:var(--card-bg);padding:10px;border-radius:10px;overflow-x:auto;overflow-y:hidden;height:170px;min-height:170px;flex-shrink:0;width:100%;scroll-behavior:smooth}
    .big-road-grid{display:grid;grid-template-rows:repeat(6,26px);grid-auto-columns:26px;grid-auto-flow:column;gap:1px;min-width:max-content}
    .big-road-cell{width:24px;height:24px;display:flex;justify-content:center;align-items:center;font-size:10px;font-weight:bold;border:1px solid #f0f0f0;background:#fff}
    .circle{width:18px;height:18px;border-radius:50%;border:2px solid transparent;display:flex;justify-content:center;align-items:center}
    .circle-P{border-color:var(--player);color:var(--player)}
    .circle-B{border-color:var(--banker);color:var(--banker)}
    .circle-T{border-color:var(--tie);color:var(--tie)}

    .bet-panel{background:var(--card-bg);padding:15px;border-radius:12px;text-align:center;box-shadow:0 5px 20px rgba(0,0,0,.08);flex-shrink:0;border-bottom:5px solid var(--primary)}
    .offset-formula{font-family:monospace;font-size:.85rem;color:#7f8c8d;background:#f0f3f4;padding:4px 10px;border-radius:4px;display:inline-block;margin-bottom:10px}
    .rec-amount{font-size:3.5rem;font-weight:900;line-height:1;color:var(--primary)}
    .rec-side{font-size:1.8rem;font-weight:800;margin-top:5px;text-transform:uppercase;letter-spacing:2px}
    .side-p{color:var(--player)} .side-b{color:var(--banker)} .side-n{color:#95a5a6}

    .controls{display:grid;grid-template-columns:1fr 1fr 80px;gap:10px;margin-top:15px}
    .btn-ctrl{padding:15px;border:none;border-radius:8px;font-size:1rem;font-weight:bold;cursor:pointer;color:#fff;touch-action:manipulation}
    .btn-ctrl:disabled{opacity:.55;cursor:not-allowed}
    .btn-p{background:var(--player)} .btn-b{background:var(--banker)} .btn-u{background:#95a5a6}

    .chart-box{background:var(--card-bg);padding:10px;border-radius:12px;flex-grow:1;min-height:250px;position:relative}

    .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:none;justify-content:center;align-items:center;z-index:999999;backdrop-filter:blur(5px)}
    .modal-box{background:#fff;padding:30px 20px;border-radius:15px;text-align:center;max-width:520px;width:90%;box-shadow:0 20px 50px rgba(0,0,0,.4);display:flex;flex-direction:column;align-items:center;border:2px solid var(--gold)}
    .btn-modal-ack{background:var(--success);color:#fff;border:none;padding:12px 20px;width:100%;border-radius:8px;font-weight:bold;cursor:pointer;font-size:1rem;margin-top:15px}

    .mode-btn-row{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-top:6px}
    .mode-btn{
      padding:10px 8px;border-radius:8px;border:1px solid #d0d7de;background:#fff;
      font-weight:1000;font-size:.72rem;cursor:pointer;
    }
    .mode-btn.on{border-color:#86efac;background:rgba(34,197,94,.08);color:#166534}
    .mode-btn.off{border-color:#fda4af;background:rgba(244,63,94,.08);color:#9f1239}
    .mode-btn small{display:block;font-weight:900;opacity:.7;margin-top:2px}

    .special-pill{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:6px 10px;border-radius:999px;font-size:.7rem;font-weight:1000;
      border:1px solid #d0d7de;background:#fff;color:#475569;
    }
    .special-pill .left{display:inline-flex;align-items:center;gap:8px;min-width:0;}
    .special-pill .right{font-size:.65rem;font-weight:900;opacity:.85;white-space:nowrap;}
    .special-pill.on{border-color:#f59e0b;background:rgba(245,158,11,.12);color:#92400e;box-shadow:0 0 0 2px rgba(245,158,11,.15);}
    .special-dot{width:10px;height:10px;border-radius:50%;background:#94a3b8;flex:0 0 auto;}
    .special-pill.on .special-dot{background:#f59e0b;box-shadow:0 0 10px rgba(245,158,11,.55);}

    .shoe-ui{display:none;background:linear-gradient(135deg,#0d5e2e,#083a1c);border:2px solid rgba(255,215,0,.35);border-radius:12px;padding:12px}
    .shoe-ui.active{display:block}
    .shoe-hdr{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px}
    .shoe-hdr .t{color:#ffd700;font-weight:900;font-size:.8rem}
    .shoe-hdr .sub{color:#d7f7e6;font-size:.6rem}
    .shoe-hdr select{background:rgba(0,0,0,.25);color:#ffd700;border:1px solid rgba(255,215,0,.35);border-radius:6px;padding:5px 8px;font-weight:800;font-size:.75rem;cursor:pointer}
    .shoe-bar{position:relative;height:20px;background:rgba(0,0,0,.25);border-radius:999px;overflow:visible;margin-bottom:8px}
    .shoe-bar-fill{height:100%;width:0%;border-radius:999px;background:linear-gradient(90deg,#27ae60,#f39c12,#e74c3c);transition:width .25s}
    .shoe-bar-txt{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font-size:.6rem;font-weight:900}
    .shoe-cut{position:absolute;top:-2px;height:24px;width:3px;background:#ffd700;box-shadow:0 0 8px rgba(255,215,0,.9);border-radius:2px}
    .shoe-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:8px}
    .shoe-bx{background:rgba(0,0,0,.22);border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:5px;text-align:center}
    .shoe-bx .lb{color:#b9f3d9;font-size:.55rem;text-transform:uppercase}
    .shoe-bx .vl{color:#fff;font-size:.9rem;font-weight:900;margin-top:1px}
    .burn-box{background:rgba(139,0,0,.22);border:1px dashed rgba(255,107,107,.7);border-radius:10px;padding:8px;margin-bottom:8px}
    .burn-box .bt{color:#ffb3b3;font-weight:900;font-size:.7rem;margin-bottom:6px}
    .burn-row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
    .burn-note{color:#ffd7d7;font-size:.6rem;margin-top:6px;line-height:1.4;white-space:pre-line}
    .deal-area{background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:10px}
    .deal-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px}
    .deal-head span{color:#ffd700;font-weight:900;font-size:.7rem}
    .deal-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .deal-col{text-align:center}
    .side-tag{display:inline-block;padding:2px 10px;border-radius:6px;color:#fff;font-weight:900;font-size:.7rem;margin-bottom:4px}
    .side-tag.tp{background:var(--player)} .side-tag.tb{background:var(--banker)}
    .card-row{display:flex;justify-content:center;gap:4px;height:60px;min-height:60px;align-items:center;flex-wrap:nowrap;overflow:hidden}
    .deal-score{font-size:1.5rem;font-weight:1000;color:#ffd700;margin-top:4px}
    .deal-result{text-align:center;margin-top:8px;font-weight:900;font-size:.8rem;padding:6px;border-radius:6px;background:rgba(0,0,0,.2)}
    .mini-card{width:38px;height:56px;background:#fff;border-radius:5px;border:1px solid #ccc;box-shadow:0 2px 8px rgba(0,0,0,.3);display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:Georgia,serif;font-weight:900;flex:0 0 auto}
    .mini-card .cr{font-size:.85rem;line-height:1}
    .mini-card .cs{font-size:.75rem;line-height:1;margin-top:1px}
    .mini-card.red{color:#c0392b} .mini-card.black{color:#2c3e50}
    .mini-card.down{background:linear-gradient(135deg,#1a3a5c,#2c5f8a);border:2px solid #3a7abd}
    .mini-card.down .cr,.mini-card.down .cs{display:none}
    .mini-card.down::after{content:'üÇ†';font-size:1.3rem;color:rgba(255,255,255,.3)}
    .mini-card.burn-reveal{border:2px solid #f44;box-shadow:0 0 12px rgba(255,68,68,.5)}
    .mini-card.placeholder{visibility:hidden}
    .shoe-newbtn{background:linear-gradient(135deg,#ffd700,#f39c12);color:#2c3e50;border:none;padding:8px 10px;border-radius:6px;font-weight:900;cursor:pointer;font-size:.75rem;white-space:nowrap}

    .sess-box{background:#ffffff;border:1px solid #e8e8e8;border-radius:10px;padding:10px}
    .sess-head{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px}
    .sess-head .t{font-weight:900;color:var(--primary);font-size:.8rem}
    .sess-actions{display:flex;gap:6px;flex-wrap:wrap}
    .btn-mini{border:none;border-radius:6px;padding:6px 8px;font-size:.7rem;font-weight:900;cursor:pointer}
    .btn-mini.export{background:var(--comm);color:#fff}
    .btn-mini.clear{background:#ecf0f1;color:#2c3e50;border:1px solid #d0d0d0}
    .sess-table-wrap{max-height:170px;overflow:auto;border:1px solid #eee;border-radius:8px}
    table.sess-table{width:100%;border-collapse:collapse;font-size:.72rem}
    .sess-table th,.sess-table td{padding:6px 6px;border-bottom:1px solid #f0f0f0;vertical-align:top;white-space:nowrap}
    .sess-table th{position:sticky;top:0;background:#f8f9fb;z-index:2;text-align:left;color:#6c7a89;font-weight:900}
    .pos{color:var(--success);font-weight:900}
    .neg{color:var(--danger);font-weight:900}
    .muted{color:#7f8c8d}
    .hist-stack{display:flex;flex-direction:column;gap:8px}

    .chk-row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .chk-row input[type="checkbox"]{width:18px;height:18px}
    .mini-note{font-size:.65rem;color:#7f8c8d;line-height:1.35;margin-top:4px}

    .mm-selected{border-top-color: var(--auto) !important;box-shadow: 0 0 0 2px rgba(142,68,173,.25), 0 8px 18px rgba(0,0,0,.08) !important;}
    .mm-selected .stat-label{ color: var(--auto) !important; }

    @media(max-width:768px){
      body{overflow-y:auto;height:auto;display:block}
      .container{grid-template-columns:1fr;height:auto;display:flex;flex-direction:column;gap:20px;padding-bottom:30px}
      .sidebar{height:auto}
      .main-content{height:auto;overflow:visible}
      .stats-grid{grid-template-columns:repeat(2,1fr)}
      .chart-box{min-height:300px}
    }
  </style>
</head>

<body>
<div class="container">
  <div class="sidebar">
    <div class="section-title" style="justify-content:center;border-bottom:none">
      <span class="badge-ult" style="font-size:.8rem;padding:5px 10px;">V3.6 ‚Äî 3 ‡πÇ‡∏´‡∏°‡∏î (LEGACY + KCAP_A + KCAP_B) | shared/per_mode ‡πÑ‡∏î‡πâ | ‡∏ï‡∏±‡∏î PURE_KELLY</span>
    </div>

    <button class="btn-reset" onclick="resetAll()">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (Hard Reset)</button>

    <div class="feature-box" style="border-color:#cfe2ff;background:#f7fbff">
      <div class="feature-title" style="color:#1d4ed8">üß¨ KCAP A/B ‡πÅ‡∏™‡∏î‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô</div>
      <div class="mini-note">
        - KCAP_A = Version A (First Loss Tier + hard cap bet ‚â§ bankrollLeft)<br/>
        - KCAP_B = Version B (Loss Base Add + Near-target auto reset + try/catch safety)
      </div>
    </div>

    <div class="section-title">üß™ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Top)</div>
    <div class="form-group">
      <label>‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏° (RNG Algorithm)</label>
      <select id="rng_method" onchange="onRngChange(); syncSimSettings('top')">
        <option value="math">üé≤ Standard (Math.random)</option>
        <option value="crypto">üîí Crypto Secure</option>
        <option value="shoe" selected>üÉè Real 8-Deck Shoe</option>
      </select>
    </div>

    <div class="shoe-ui" id="shoe_ui">
      <div class="shoe-hdr">
        <div>
          <div class="t">üÉè 8-Deck Shoe ‚Äî Casino Real</div>
          <div class="sub">Burn Card + Cut Card (Penetration)</div>
        </div>
        <select id="shoe_pen" onchange="onPenChange()">
          <option value="50">‡πÉ‡∏ä‡πâ‡πÑ‡∏û‡πà 50%</option>
          <option value="60" selected>‡πÉ‡∏ä‡πâ‡πÑ‡∏û‡πà 60%</option>
          <option value="70">‡πÉ‡∏ä‡πâ‡πÑ‡∏û‡πà 70%</option>
          <option value="80">‡πÉ‡∏ä‡πâ‡πÑ‡∏û‡πà 80%</option>
        </select>
      </div>

      <div class="shoe-bar">
        <div class="shoe-bar-fill" id="sb_fill"></div>
        <div class="shoe-cut" id="sb_cut" style="left:60%"></div>
        <div class="shoe-bar-txt" id="sb_txt">0 / 416 (0.0%)</div>
      </div>

      <div class="shoe-grid">
        <div class="shoe-bx"><div class="lb">‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠</div><div class="vl" id="sh_rem">416</div></div>
        <div class="shoe-bx"><div class="lb">‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß</div><div class="vl" id="sh_used">0</div></div>
        <div class="shoe-bx"><div class="lb">Shoe #</div><div class="vl" id="sh_no">0</div></div>
      </div>

      <div class="burn-box" id="burn_box" style="display:none">
        <div class="bt">üî• Burn Card Ceremony</div>
        <div class="burn-row">
          <span style="color:#ffd7d7;font-size:.65rem">‡πÑ‡∏û‡πà‡∏´‡∏á‡∏≤‡∏¢:</span>
          <span id="burn_card_slot"></span>
          <span id="burn_label" style="color:#ffd7d7;font-size:.7rem;font-weight:900"></span>
        </div>
        <div class="burn-row" id="burn_down_row" style="margin-top:4px"></div>
        <div class="burn-note" id="burn_note"></div>
      </div>

      <div class="deal-area" id="deal_area" style="display:none">
        <div class="deal-head">
          <span>üìã ‡∏ï‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</span>
          <button class="shoe-newbtn" onclick="initShoe(true)">üîÑ ‡∏™‡∏±‡∏ö‡πÑ‡∏û‡πà‡πÉ‡∏´‡∏°‡πà</button>
        </div>
        <div class="deal-grid">
          <div class="deal-col">
            <div class="side-tag tp">PLAYER</div>
            <div class="card-row" id="pc_row"></div>
            <div class="deal-score" id="pc_sc">-</div>
          </div>
          <div class="deal-col">
            <div class="side-tag tb">BANKER</div>
            <div class="card-row" id="bc_row"></div>
            <div class="deal-score" id="bc_sc">-</div>
          </div>
        </div>
        <div class="deal-result" id="deal_res" style="color:#ffd700">‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡∏Å‡πÑ‡∏û‡πà...</div>
      </div>
    </div>

    <div class="form-group">
      <input type="number" id="sim_hands" value="1" placeholder="‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡∏≤" oninput="syncSimSettings('top')" />
      <button class="btn-action btn-sim" onclick="runSimulation()">‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Simulate)</button>

      <label style="margin-top:10px;">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß Auto Sim:</label>
      <select id="sim_speed" onchange="syncSimSettings('top')">
        <option value="0">üöÄ ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (Instant)</option>
        <option value="20" selected>‚ö° ‡πÄ‡∏£‡πá‡∏ß (Fast)</option>
      </select>

      <button class="btn-action btn-auto" id="btn_auto_sim" onclick="toggleAutoSim()">üöÄ Auto Sim</button>
      <button class="btn-action btn-stop" id="btn_stop_sim" onclick="stopAutoSim()">‚èπ STOP</button>

      <div id="sim_stats_display" style="display:none;font-size:.75rem;text-align:center;margin-top:5px;">
        ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà: <span id="sim_round_count">0</span> | ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (cycle): <span id="sim_success_count" style="color:green;">0</span>
      </div>
    </div>

    <div class="section-title">‚öôÔ∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (Settings)</div>

    <div class="feature-box" style="border-color:#bfc9ca;background:#fbfcfc">
      <div class="feature-title" style="color:var(--primary);">üß† Netting (Multi-Strategy)</div>
      <div class="form-group">
        <label>Netting Mode</label>
        <select id="net_mode" onchange="updateUI()">
          <option value="weight" selected>weight (sum weights)</option>
          <option value="count">count (ignore weights)</option>
        </select>
      </div>
      <div class="dual-input">
        <div class="form-group">
          <label>min_strength (‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ = WAIT)</label>
          <input type="number" id="min_strength" value="4.03" step="0.01" oninput="updateUI()" />
        </div>
        <div class="form-group">
          <label>Reset Road ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏ö cycle</label>
          <select id="reset_road_on_cycle" onchange="updateUI()">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
      </div>

      <div class="section-title" style="margin-top:8px;">üó≥Ô∏è Strategy Votes (5)</div>
      <div class="chk-row">
        <input type="checkbox" id="use_offset" checked onchange="updateUI()" />
        <label for="use_offset" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">1) Offset</label>
      </div>
      <div class="form-group">
        <label>Weight (Offset)</label>
        <input type="number" id="w_offset" value="3.86" step="0.01" oninput="updateUI()" />
      </div>

      <div class="chk-row">
        <input type="checkbox" id="use_anti_last" checked onchange="updateUI()" />
        <label for="use_anti_last" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">2) Anti Last</label>
      </div>
      <div class="form-group">
        <label>Weight (Anti Last)</label>
        <input type="number" id="w_anti_last" value="0.96" step="0.01" oninput="updateUI()" />
      </div>

      <div class="chk-row">
        <input type="checkbox" id="use_follow_last" checked onchange="updateUI()" />
        <label for="use_follow_last" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">3) Follow Last</label>
      </div>
      <div class="form-group">
        <label>Weight (Follow Last)</label>
        <input type="number" id="w_follow_last" value="3.71" step="0.01" oninput="updateUI()" />
      </div>

      <div class="chk-row">
        <input type="checkbox" id="use_something_else" checked onchange="updateUI()" />
        <label for="use_something_else" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">4) Something Else</label>
      </div>
      <div class="form-group">
        <label>Weight (Something Else)</label>
        <input type="number" id="w_something_else" value="2.10" step="0.01" oninput="updateUI()" />
      </div>

      <div class="chk-row">
        <input type="checkbox" id="use_policy_ai" checked onchange="updateUI()" />
        <label for="use_policy_ai" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">5) Policy AI</label>
      </div>
      <div class="form-group">
        <label>Weight (Policy AI)</label>
        <input type="number" id="w_policy_ai" value="3.99" step="0.01" oninput="updateUI()" />
      </div>
    </div>

    <div class="feature-box" style="border-color:#d6eaf8;background:#f8fbff">
      <div class="feature-title" style="color:#2471a3">‚ö° X-Trigger</div>
      <div class="chk-row">
        <input type="checkbox" id="require_both_x" checked onchange="updateUI()" />
        <label for="require_both_x" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">Require Both X</label>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>x_live_hands_on_trigger</label>
          <input type="number" id="x_live_hands_on_trigger" value="11" step="1" min="1" oninput="updateUI()" />
        </div>
        <div class="form-group">
          <label>MAX_WAIT_HANDS</label>
          <input type="number" id="max_wait_hands" value="50" step="1" min="1" oninput="updateUI()" />
        </div>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>x_mult_pass</label>
          <input type="number" id="x_mult_pass" value="1.24" step="0.01" oninput="updateUI()" />
        </div>
        <div class="form-group">
          <label>x_mult_fail</label>
          <input type="number" id="x_mult_fail" value="0.10" step="0.01" oninput="updateUI()" />
        </div>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>x_rule_mode</label>
          <select id="x_rule_mode" onchange="updateUI()">
            <option value="D_stop" selected>D_stop</option>
            <option value="C_multiplier">C_multiplier</option>
          </select>
        </div>
        <div class="form-group">
          <label>x_times_target</label>
          <input type="number" id="x_times_target" value="2" step="1" min="1" oninput="updateUI()" />
        </div>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>x_count_source</label>
          <select id="x_count_source" onchange="updateUI()">
            <option value="include_virtual" selected>include_virtual</option>
            <option value="live_only">live_only</option>
          </select>
        </div>
        <div class="form-group">
          <label>x_reset_after_trigger</label>
          <select id="x_reset_after_trigger" onchange="updateUI()">
            <option value="none" selected>none</option>
            <option value="cycle">cycle</option>
          </select>
        </div>
      </div>

      <div class="chk-row">
        <input type="checkbox" id="x_stop_on_pass" checked onchange="updateUI()" />
        <label for="x_stop_on_pass" style="margin:0;font-size:.78rem;font-weight:800;color:#2c3e50">x_stop_on_pass</label>
      </div>
      <div class="mini-note">‚úÖ D_stop ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏Ñ‡πà 1 ‡∏°‡∏∑‡∏≠‡∏´‡∏•‡∏±‡∏á WIN (‡πÑ‡∏°‡πà‡∏Ñ‡πâ‡∏≤‡∏á)</div>
    </div>

    <div class="comm-box">
      <div class="comm-title">
        <span>üí∞ Commission / Rolling Rebate</span>
        <button class="btn-guide" onclick="showGuideModal()">üìñ</button>
      </div>
      <div class="form-group">
        <label>‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏° / ‡πÇ‡∏£‡∏•‡∏•‡∏¥‡πà‡∏á (%)</label>
        <input type="number" id="commission_rate" value="0.9" step="0.01" min="0" oninput="updateUI()">
      </div>
      <div class="comm-grid">
        <div class="comm-stat"><div class="lb">‡∏¢‡∏≠‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏™‡∏∞‡∏™‡∏° (cycle)</div><div class="vl" id="comm_turnover">0</div></div>
        <div class="comm-stat"><div class="lb">‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏™‡∏∞‡∏™‡∏° (cycle)</div><div class="vl" id="comm_total">0</div></div>
        <div class="comm-stat"><div class="lb">‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô (cycle)</div><div class="vl" id="comm_hands">0</div></div>
        <div class="comm-stat"><div class="lb">Cycle + ‡∏Ñ‡∏≠‡∏°</div><div class="vl" id="comm_net_plus">0</div></div>
      </div>
    </div>

    <div class="section-title">üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°)</div>
    <div class="comm-box" style="border-color:#cfe2ff;background:#f7fbff">
      <div class="comm-title" style="color:#1d4ed8"><span>Lifetime Stats (LEGACY / KCAP_A / KCAP_B)</span></div>
      <div class="comm-grid">
        <div class="comm-stat" style="background:rgba(29,78,216,.06)"><div class="lb">Net Profit</div><div class="vl" id="all_net">0</div></div>
        <div class="comm-stat" style="background:rgba(29,78,216,.06)"><div class="lb">Net + Commission</div><div class="vl" id="all_net_comm">0</div></div>
        <div class="comm-stat" style="background:rgba(29,78,216,.06)"><div class="lb">Max Drawdown</div><div class="vl" id="all_max_dd">0</div></div>
        <div class="comm-stat" style="background:rgba(29,78,216,.06)"><div class="lb">Max Bet</div><div class="vl" id="all_max_bet">0</div></div>
      </div>
      <div class="mini-note">‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏µ: ‡∏Å‡∏≥‡πÑ‡∏£ = ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß, ‡∏ï‡∏¥‡∏î‡∏•‡∏ö = ‡πÅ‡∏î‡∏á (‡πÅ‡∏¢‡∏Å‡πÇ‡∏´‡∏°‡∏î)</div>
    </div>

    <div class="target-box">
      <div class="target-title">üéØ Target Profit (‡∏ï‡πà‡∏≠ cycle: ‡πÅ‡∏¢‡∏Å‡πÇ‡∏´‡∏°‡∏î)</div>
      <div style="display:grid;grid-template-columns:1fr;gap:6px;margin-bottom:8px;">
        <div class="special-pill" id="special_pill_legacy">
          <span class="left"><span class="special-dot"></span><span id="special_txt_legacy">LEGACY: ...</span></span>
          <span class="right" id="special_rt_legacy">-</span>
        </div>
        <div class="special-pill" id="special_pill_kcapA">
          <span class="left"><span class="special-dot"></span><span id="special_txt_kcapA">KCAP_A: ...</span></span>
          <span class="right" id="special_rt_kcapA">-</span>
        </div>
        <div class="special-pill" id="special_pill_kcapB">
          <span class="left"><span class="special-dot"></span><span id="special_txt_kcapB">KCAP_B: ...</span></span>
          <span class="right" id="special_rt_kcapB">-</span>
        </div>
      </div>

      <div class="chk-row" style="margin-bottom:6px;">
        <input type="checkbox" id="use_dynamic_target" onchange="updateUI()" checked />
        <label for="use_dynamic_target" style="margin:0;font-size:.78rem;font-weight:900;color:#2c3e50">
          ‡πÉ‡∏ä‡πâ Dynamic Target (% ‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏ô) ‚Äî default ON
        </label>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>Dynamic Target (% ‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏ô)</label>
          <input type="number" id="target_pct" value="1" step="0.1" min="0" oninput="updateUI()">
        </div>
        <div class="form-group">
          <label>Fixed Target (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î Dynamic)</label>
          <input type="number" id="target_profit" value="1000" step="0.01" oninput="updateUI()">
        </div>
      </div>
      <div class="mini-note">
        Special Mode (‡πÅ‡∏¢‡∏Å‡πÇ‡∏´‡∏°‡∏î): ‡∏ñ‡πâ‡∏≤ <b>Lifetime(Net+Comm) ‚â• 1000</b> ‡∏Ç‡∏≠‡∏á‡πÇ‡∏´‡∏°‡∏î‡∏ô‡∏±‡πâ‡∏ô ‚Üí Target = <b>0.05%</b>
      </div>
    </div>

    <div class="feature-box" id="survival_box">
      <div class="feature-title">üõ°Ô∏è Survival Mode</div>
      <div class="chk-row" style="margin-bottom:6px;">
        <input type="checkbox" id="enable_survival" onchange="updateUI()" />
        <label for="enable_survival" style="margin:0;font-size:.78rem;font-weight:900;color:#2c3e50">Enable</label>
      </div>
      <div class="dual-input">
        <div class="form-group"><label>Trigger DD%</label><input type="number" id="surv_trigger" value="99.0" step="0.01" oninput="updateUI()"></div>
        <div class="form-group"><label>Div Multiplier</label><input type="number" id="surv_div" value="6.11" step="0.01" oninput="updateUI()"></div>
      </div>
    </div>

    <div class="feature-box" style="border-color:#e5e7eb;background:#ffffff">
      <div class="feature-title" style="color:var(--primary);">üéöÔ∏è First Loss Bet (3 Levels) ‚Äî KCAP_A ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô</div>
      <div class="form-group">
        <label>‡∏°‡∏∑‡∏≠‡πÅ‡∏£‡∏Å‡∏ï‡∏≠‡∏ô‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô (stage=0) ‚Äî ‡∏≠‡∏¥‡∏á‡∏à‡∏≤‡∏Å deficit</label>
        <select id="first_loss_tier" onchange="updateUI()">
          <option value="low" selected>LOW</option>
          <option value="mid">MID</option>
          <option value="high">HIGH</option>
        </select>
      </div>
    </div>

    <div class="form-group"><label>‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (Bankroll)</label><input type="number" id="init_bank" value="1000000.0" oninput="updateUI()"></div>
    <div class="form-group"><label>‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (Max Bet)</label><input type="number" id="max_bet_cap" value="250000.0" oninput="updateUI()"></div>

    <div class="dual-input">
      <div class="form-group"><label>‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (Min Bet)</label><input type="number" id="min_bet" value="50" oninput="updateUI()"></div>
      <div class="form-group"><label style="color:var(--primary);">‡∏ä‡∏¥‡∏õ‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î (Chip Unit)</label><input type="number" id="chip_size" value="50" style="border:2px solid var(--primary);font-weight:bold" oninput="updateUI()"></div>
    </div>

    <div class="feature-box" style="border-color:#b8daff;background:#f7fbff">
      <div class="feature-title" style="color:#1d4ed8">üß© Multi-Mode Compare</div>
      <div class="form-group">
        <label>Signal Source</label>
        <select id="signal_source" onchange="updateUI()">
          <option value="shared">Shared ‚Äî side ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á 3 ‡πÇ‡∏´‡∏°‡∏î</option>
          <option value="per_mode" selected>Per-Mode ‚Äî side ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î</option>
        </select>
      </div>

      <div class="section-title" style="margin-top:8px;">‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ ‚Äú‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á‚Äù</div>
      <div class="mode-btn-row">
        <button class="mode-btn" id="btn_mode_legacy" onclick="toggleMode('legacy')">LEGACY<small id="lbl_mode_legacy">ON</small></button>
        <button class="mode-btn" id="btn_mode_kcapA" onclick="toggleMode('kcapA')">KCAP_A<small id="lbl_mode_kcapA">ON</small></button>
        <button class="mode-btn" id="btn_mode_kcapB" onclick="toggleMode('kcapB')">KCAP_B<small id="lbl_mode_kcapB">ON</small></button>
      </div>
      <div class="mini-note">‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î: ‡πÑ‡∏°‡πà‡∏•‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏û‡∏±‡∏ô/‡πÑ‡∏°‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï lifetime/‡∏Å‡∏£‡∏≤‡∏ü ‡πÅ‡∏•‡∏∞‡∏ã‡πà‡∏≠‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡πÉ‡∏ô‡∏Å‡∏£‡∏≤‡∏ü</div>

      <div class="form-group" style="margin-top:10px;">
        <label>Kelly p source (KCAP_A + KCAP_B)</label>
        <select id="kelly_p_source" onchange="updateUI()">
          <option value="fixed">Fixed p</option>
          <option value="logistic" selected>Logistic from Net Strength</option>
        </select>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>p_fixed (Player)</label>
          <input type="number" id="p_fixed_p" value="0.510" step="0.001" min="0.001" max="0.999" oninput="updateUI()" />
        </div>
        <div class="form-group">
          <label>p_fixed (Banker)</label>
          <input type="number" id="p_fixed_b" value="0.500" step="0.001" min="0.001" max="0.999" oninput="updateUI()" />
        </div>
      </div>

      <div class="dual-input">
        <div class="form-group">
          <label>p_cap</label>
          <input type="number" id="p_cap" value="0.540" step="0.001" min="0.500" max="0.900" oninput="updateUI()" />
        </div>
        <div class="form-group">
          <label>k (logistic slope)</label>
          <input type="number" id="p_log_k" value="0.35" step="0.01" min="0.01" max="5" oninput="updateUI()" />
        </div>
      </div>

      <div class="form-group">
        <label>edge_max</label>
        <input type="number" id="edge_max" value="0.040" step="0.001" min="0" max="0.200" oninput="updateUI()" />
      </div>

      <div class="section-title" style="margin-top:10px;">üßØ Kelly Risk Cap (KCAP_A + KCAP_B)</div>
      <div class="dual-input">
        <div class="form-group">
          <label>kelly_scale (0.25‚Äì1.00)</label>
          <input type="number" id="kelly_scale" value="0.50" step="0.05" min="0" max="1" oninput="updateUI()" />
        </div>
        <div class="form-group">
          <label>kcap_max_pct (% ‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ / ‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πâ)</label>
          <input type="number" id="kcap_max_pct" value="0.50" step="0.05" min="0" max="100" oninput="updateUI()" />
        </div>
      </div>
      <div class="mini-note">‡πÄ‡∏°‡∏∑‡πà‡∏≠ cycle ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô (cp&lt;0) ‡∏à‡∏∞ ‚Äú‡πÑ‡∏°‡πà‚Äù ‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏î‡∏≤‡∏ô kelly_scale + kcap_max_pct</div>
    </div>

    <button class="btn-restore" onclick="restoreRecommended()">‚Ü∫ ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ (DEFAULT)</button>

    <div class="section-title">üéØ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ (Status) ‚Äî ‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á</div>
    <div class="monitor-box">
      <span class="monitor-label">Cycle Profit / Cycle HWM</span>
      <div id="target_status_display" class="monitor-val">0 / 0</div>
      <div class="cycle-monitor">
        <span>Cycle Profit / Target:</span>
        <span id="cycle_profit_disp" style="color:var(--target);font-weight:bold;">0</span>
      </div>
      <div style="font-size:.7rem;color:#d7f7e6;margin-top:8px;">
        ‡∏ó‡∏∏‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (‡∏£‡∏ß‡∏°‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°): <b id="bankroll_left_disp">0</b><br/>
        Cycle # (L / A / B): <b id="cycle_no_disp">-</b>
      </div>
    </div>

    <div class="sess-box">
      <div class="sess-head">
        <div class="t">üìí Cycle History ‚Äî ‡πÅ‡∏¢‡∏Å‡πÇ‡∏´‡∏°‡∏î</div>
        <div class="sess-actions">
          <button class="btn-mini export" onclick="exportSessionHistoryAll()">Export JSON</button>
          <button class="btn-mini clear" onclick="clearSessionHistoryAll()">Clear</button>
        </div>
      </div>

      <div class="hist-stack">
        <div>
          <div class="section-title" style="margin:0 0 6px 0;border-bottom:none;">LEGACY</div>
          <div class="sess-table-wrap">
            <table class="sess-table">
              <thead><tr><th>#</th><th>Reason</th><th>Hands</th><th>Cycle</th><th>Comm</th><th>Net+Comm</th><th>Left</th><th>Time</th></tr></thead>
              <tbody id="session_table_body_legacy"><tr><td colspan="8" class="muted" style="padding:10px">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ</td></tr></tbody>
            </table>
          </div>
        </div>
        <div>
          <div class="section-title" style="margin:0 0 6px 0;border-bottom:none;">KCAP_A</div>
          <div class="sess-table-wrap">
            <table class="sess-table">
              <thead><tr><th>#</th><th>Reason</th><th>Hands</th><th>Cycle</th><th>Comm</th><th>Net+Comm</th><th>Left</th><th>Time</th></tr></thead>
              <tbody id="session_table_body_kcapA"><tr><td colspan="8" class="muted" style="padding:10px">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ</td></tr></tbody>
            </table>
          </div>
        </div>
        <div>
          <div class="section-title" style="margin:0 0 6px 0;border-bottom:none;">KCAP_B</div>
          <div class="sess-table-wrap">
            <table class="sess-table">
              <thead><tr><th>#</th><th>Reason</th><th>Hands</th><th>Cycle</th><th>Comm</th><th>Net+Comm</th><th>Left</th><th>Time</th></tr></thead>
              <tbody id="session_table_body_kcapB"><tr><td colspan="8" class="muted" style="padding:10px">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ</td></tr></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="section-title">üß† Monitors ‚Äî ‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á</div>
    <div class="brain-monitor">
      <div class="brain-col">
        <div class="brain-head txt-p">CENTRAL STAKER</div>
        <div class="brain-val txt-p" id="mon_bal">0</div>
        <div class="brain-info" id="mon_info">Wait:0 | Stg:0 | CL:0</div>
      </div>
      <div class="brain-col">
        <div class="brain-head txt-b">NET (side/strength)</div>
        <div class="brain-val txt-b" id="mon_net">WAIT</div>
        <div class="brain-info" id="mon_net_info">P:0 B:0</div>
      </div>
    </div>

    <div class="section-title">üß™ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Bottom)</div>
    <div class="form-group">
      <label>‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏∏‡πà‡∏°</label>
      <select id="rng_method_bot" onchange="onRngChange(); syncSimSettings('bot')">
        <option value="math">üé≤ Standard</option>
        <option value="crypto">üîí Crypto</option>
        <option value="shoe" selected>üÉè Real Shoe</option>
      </select>
    </div>

    <div class="form-group">
      <input type="number" id="sim_hands_bot" value="1" oninput="syncSimSettings('bot')">
      <button class="btn-action btn-sim" onclick="runSimulation()">‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏ú‡∏• (Simulate)</button>

      <label style="margin-top:10px;">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß Auto Sim:</label>
      <select id="sim_speed_bot" onchange="syncSimSettings('bot')">
        <option value="0">üöÄ ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ</option>
        <option value="20" selected>‚ö° ‡πÄ‡∏£‡πá‡∏ß</option>
      </select>

      <button class="btn-action btn-auto" id="btn_auto_sim_bot" onclick="toggleAutoSim()">üöÄ Auto Sim</button>
      <button class="btn-action btn-stop" id="btn_stop_sim_bot" onclick="stopAutoSim()">‚èπ STOP</button>

      <div id="sim_stats_display_bot" style="display:none;font-size:.75rem;text-align:center;margin-top:5px;">
        ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà: <span id="sim_round_count_bot">0</span> | ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (cycle): <span id="sim_success_count_bot" style="color:green;">0</span>
      </div>
    </div>

    <button class="btn-reset" onclick="resetAll()">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (Hard Reset)</button>
  </div>

  <div class="main-content">
    <div class="stats-grid">
      <div class="stat-card profit"><div class="stat-label">Cycle Profit (‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á)</div><div class="stat-value" id="disp_net">0</div></div>
      <div class="stat-card comm"><div class="stat-label">Cycle + Commission (‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á)</div><div class="stat-value" id="disp_net_comm" style="color:var(--comm);">0</div></div>
      <div class="stat-card"><div class="stat-label">Max Drawdown (run: ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á)</div><div class="stat-value" id="disp_dd">0</div></div>
      <div class="stat-card loss"><div class="stat-label">Max Bet (cycle: ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á)</div><div class="stat-value" id="disp_maxbet">0</div></div>
      <div class="stat-card"><div class="stat-label">Hands (GLOBAL)</div><div class="stat-value" id="disp_hands">0</div></div>
      <div class="stat-card pre"><div class="stat-label">Net Mode</div><div class="stat-value" id="disp_mode">weight</div></div>
      <div class="stat-card pre"><div class="stat-label">Net Strength (‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á)</div><div class="stat-value" id="disp_strength">0</div></div>
      <div class="stat-card comm"><div class="stat-label">Commission (cycle: ‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á)</div><div class="stat-value" id="disp_comm_total" style="color:var(--comm);">0</div></div>
    </div>

    <div class="stats-grid" style="grid-template-columns:repeat(3,1fr);">
      <div class="stat-card pre" id="mm_card_legacy" onclick="setDisplayMode('legacy')" style="cursor:pointer;">
        <div class="stat-label">LEGACY</div>
        <div class="stat-value" id="mm_legacy_line">-</div>
        <div style="margin-top:6px;font-weight:900" id="mm_legacy_rec">-</div>
      </div>
      <div class="stat-card pre" id="mm_card_kcapA" onclick="setDisplayMode('kcapA')" style="cursor:pointer;">
        <div class="stat-label">KCAP_A</div>
        <div class="stat-value" id="mm_kcapA_line">-</div>
        <div style="margin-top:6px;font-weight:900" id="mm_kcapA_rec">-</div>
      </div>
      <div class="stat-card pre" id="mm_card_kcapB" onclick="setDisplayMode('kcapB')" style="cursor:pointer;">
        <div class="stat-label">KCAP_B</div>
        <div class="stat-value" id="mm_kcapB_line">-</div>
        <div style="margin-top:6px;font-weight:900" id="mm_kcapB_rec">-</div>
      </div>
    </div>

    <div class="road-scroll-wrapper"><div class="big-road-grid" id="road_container"></div></div>

    <div class="bet-panel">
      <div class="form-group" style="max-width:260px;margin:0 auto 8px auto;">
        <label style="text-align:left;">‡πÅ‡∏™‡∏î‡∏á Panel ‡πÉ‡∏´‡∏ç‡πà‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î</label>
        <select id="display_mode" onchange="updateUI()">
          <option value="legacy">LEGACY</option>
          <option value="kcapA" selected>KCAP_A</option>
          <option value="kcapB">KCAP_B</option>
        </select>
      </div>

      <div class="offset-formula" id="formula_disp">-</div>
      <div class="rec-amount" id="rec_amount">0</div>
      <div class="rec-side side-n" id="rec_side">WAIT</div>
      <div class="controls">
        <button class="btn-ctrl btn-p" onclick="processResultAll('P')">PLAYER</button>
        <button class="btn-ctrl btn-b" onclick="processResultAll('B')">BANKER</button>
        <button class="btn-ctrl btn-u" onclick="undo()">UNDO</button>
      </div>
    </div>

    <div class="chart-box"><canvas id="profitChart"></canvas></div>
  </div>
</div>

<div class="modal-overlay" id="guideModal">
  <div class="modal-box" style="border:2px solid var(--comm); text-align:left;">
    <div style="width:100%;text-align:center;font-size:2.2rem;">üìñ</div>
    <div style="width:100%;text-align:center;font-weight:1000;color:var(--comm);font-size:1.05rem;">‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏±‡πâ‡∏ô</div>
    <div style="font-size:.9rem;line-height:1.8;color:#2c3e50;margin-top:10px;">
      - KCAP_A ‡πÅ‡∏•‡∏∞ KCAP_B ‚Äú‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‚Äù (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ 3 ‡πÇ‡∏´‡∏°‡∏î)<br/>
      - Signal Source = <b>shared</b> ‡πÉ‡∏ä‡πâ‡πÇ‡∏´‡∏°‡∏î LEGACY ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏°)<br/>
      - AutoSave ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å 1 ‡∏ô‡∏≤‡∏ó‡∏µ + ‡∏ï‡∏≠‡∏ô‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤
    </div>
    <button class="btn-modal-ack" style="background:var(--comm);" onclick="closeGuideModal()">‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏•‡πâ‡∏ß ‚úì</button>
  </div>
</div>

<script>
const FIXED = { MIN_BET: 50.0, CHIP_SIZE: 50.0, REBATE_RATE: 0.9, RNG_METHOD: 'shoe', SHOE_PEN: 60, MAX_WAIT_HANDS: 50 };

/* =========================
   Real Shoe Engine
   ========================= */
const SUITS=['‚ô†','‚ô•','‚ô¶','‚ô£'];
const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const BAC_VAL={A:1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':0,J:0,Q:0,K:0};
const BURN_VAL={A:1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,J:10,Q:10,K:10};
let shoe={deck:[],total:416,used:0,no:0,pen:60,cutAt:0,lastHand:null,burnInfo:null,ready:false};

function isRedSuit(s){return s==='‚ô•'||s==='‚ô¶';}
function cryptoRandInt(maxExclusive){
  if(!(window.crypto && window.crypto.getRandomValues)) throw new Error("Crypto RNG not available");
  const a=new Uint32Array(1); window.crypto.getRandomValues(a); return a[0] % maxExclusive;
}
function randFloat01(){
  if(!(window.crypto && window.crypto.getRandomValues)) throw new Error("Crypto RNG not available");
  const a=new Uint32Array(1); window.crypto.getRandomValues(a); return a[0] / 4294967296;
}
function pickCutAt(total, penPercent){
  const target = Math.floor(total*(penPercent/100));
  const jitter = Math.floor(total*0.04);
  const lo = Math.max(60, target - jitter);
  const hi = Math.min(total - 20, target + jitter);
  return lo + Math.floor(randFloat01() * (hi - lo + 1));
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=cryptoRandInt(i+1);
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}
function build8Deck(){
  const d=[];
  for(let k=0;k<8;k++) for(const s of SUITS) for(const r of RANKS) d.push({rank:r,suit:s,v:BAC_VAL[r]});
  return d;
}
function bacScore(cards){ let t=0; for(const c of cards) t+=c.v; return t%10; }
function makeCardEl(card, faceDown=false){
  const div=document.createElement('div');
  div.className='mini-card'+(faceDown?' down':(isRedSuit(card.suit)?' red':' black'));
  if(!faceDown) div.innerHTML=`<div class="cr">${card.rank}</div><div class="cs">${card.suit}</div>`;
  return div;
}
function makeBurnRevealEl(card){ const el=makeCardEl(card,false); el.classList.add('burn-reveal'); return el; }
function shoeNeedCut(){ return shoe.used>=shoe.cutAt || shoe.deck.length<6; }
function shoeDraw(){ if(shoe.deck.length===0) return null; shoe.used++; return shoe.deck.pop(); }
function doBurnCeremony(){
  const reveal=shoeDraw(); if(!reveal) return;
  const burnN=BURN_VAL[reveal.rank];
  const downs=[];
  for(let i=0;i<burnN;i++){ const c=shoeDraw(); if(!c) break; downs.push(c); }
  shoe.burnInfo={reveal,burnN,downs};
  document.getElementById('burn_box').style.display='block';
  const slot=document.getElementById('burn_card_slot');
  slot.innerHTML=''; slot.appendChild(makeBurnRevealEl(reveal));
  document.getElementById('burn_label').innerText=`${reveal.rank}${reveal.suit} ‚Üí ‡∏ó‡∏¥‡πâ‡∏á‡∏Ñ‡∏ß‡πà‡∏≥ ${burnN} ‡πÉ‡∏ö`;
  const row=document.getElementById('burn_down_row');
  row.innerHTML=''; downs.forEach(c=>row.appendChild(makeCardEl(c,true)));
  document.getElementById('burn_note').innerText=
`‡∏ò‡∏£‡∏£‡∏°‡πÄ‡∏ô‡∏µ‡∏¢‡∏°‡∏ö‡∏≤‡∏Ñ‡∏≤‡∏£‡πà‡∏≤:
- ‡∏´‡∏á‡∏≤‡∏¢‡πÑ‡∏û‡πà‡πÉ‡∏ö‡πÅ‡∏£‡∏Å‡∏î‡∏π‡πÅ‡∏ï‡πâ‡∏°
- ‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏û‡πà‡πÉ‡∏ö‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏ß‡πà‡∏≥‡∏ï‡∏≤‡∏°‡πÅ‡∏ï‡πâ‡∏°
A=1, 2-9=‡∏ï‡∏≤‡∏°‡πÄ‡∏•‡∏Ç, 10/J/Q/K=10
‡∏£‡∏ß‡∏°‡πÑ‡∏û‡πà‡∏ñ‡∏π‡∏Å‡∏î‡∏∂‡∏á‡∏≠‡∏≠‡∏Å: ${burnN+1} ‡πÉ‡∏ö`;
}
function initShoe(force=false){
  if(shoe.ready && !force) return;
  const d=shuffle(shuffle(shuffle(build8Deck())));
  shoe.deck=d; shoe.total=d.length; shoe.used=0; shoe.no++;
  shoe.lastHand=null; shoe.burnInfo=null; shoe.ready=true;
  shoe.pen=parseInt(document.getElementById('shoe_pen').value)||60;
  shoe.cutAt = pickCutAt(shoe.total, shoe.pen);
  doBurnCeremony();
  refreshShoeUI();
}
function dealBaccarat(_retry=0){
  if(_retry > 5) throw new Error("dealBaccarat retry overflow (shoe may be broken)");
  if(!shoe.ready) initShoe(true);
  if(shoeNeedCut()) initShoe(true);
  const P=[shoeDraw(),shoeDraw()];
  const B=[shoeDraw(),shoeDraw()];
  if(!P[0]||!P[1]||!B[0]||!B[1]){ initShoe(true); return dealBaccarat(_retry+1); }
  let p=bacScore(P), b=bacScore(B);
  const pNat=p>=8, bNat=b>=8;
  let pThird=null;
  if(!pNat && !bNat){
    if(p<=5){
      pThird=shoeDraw();
      if(pThird){ P.push(pThird); p=bacScore(P); }
    }
    if(pThird===null){
      if(b<=5){
        const b3=shoeDraw();
        if(b3){ B.push(b3); b=bacScore(B); }
      }
    }else{
      const pt=pThird.v;
      let bankerDraw=false;
      if(b<=2) bankerDraw=true;
      else if(b===3 && pt!==8) bankerDraw=true;
      else if(b===4 && pt>=2 && pt<=7) bankerDraw=true;
      else if(b===5 && pt>=4 && pt<=7) bankerDraw=true;
      else if(b===6 && pt>=6 && pt<=7) bankerDraw=true;
      if(bankerDraw){
        const b3=shoeDraw();
        if(b3){ B.push(b3); b=bacScore(B); }
      }
    }
  }
  const res=(p>b)?'P':(b>p?'B':'T');
  shoe.lastHand={P,B,p,b,res};
  refreshShoeUI();
  return res;
}
function refreshShoeUI(){
  const ui=document.getElementById('shoe_ui');
  if(!ui) return;
  const m=document.getElementById('rng_method').value;
  if(m!=='shoe'){ ui.classList.remove('active'); return; }
  ui.classList.add('active');
  if(!shoe.ready) return;
  const pct=(shoe.used/shoe.total)*100;
  document.getElementById('sb_fill').style.width=pct.toFixed(1)+'%';
  document.getElementById('sb_txt').innerText=`${shoe.used} / ${shoe.total} (${pct.toFixed(1)}%)`;
  document.getElementById('sb_cut').style.left=((shoe.cutAt/shoe.total)*100).toFixed(1)+'%';
  document.getElementById('sh_rem').innerText=shoe.total-shoe.used;
  document.getElementById('sh_used').innerText=shoe.used;
  document.getElementById('sh_no').innerText=shoe.no;
  const dealArea=document.getElementById('deal_area');
  if(shoe.lastHand){
    dealArea.style.display='block';
    const pc=document.getElementById('pc_row');
    const bc=document.getElementById('bc_row');
    pc.innerHTML=''; bc.innerHTML='';
    shoe.lastHand.P.forEach(c=>pc.appendChild(makeCardEl(c,false)));
    shoe.lastHand.B.forEach(c=>bc.appendChild(makeCardEl(c,false)));
    while(pc.children.length<3){ const ph=document.createElement('div'); ph.className='mini-card placeholder'; pc.appendChild(ph); }
    while(bc.children.length<3){ const ph=document.createElement('div'); ph.className='mini-card placeholder'; bc.appendChild(ph); }
    document.getElementById('pc_sc').innerText=shoe.lastHand.p;
    document.getElementById('bc_sc').innerText=shoe.lastHand.b;
    const dr=document.getElementById('deal_res');
    if(shoe.lastHand.res==='P'){ dr.innerText=`PLAYER WIN ‚Äî P:${shoe.lastHand.p} vs B:${shoe.lastHand.b}`; dr.style.color='#3498db'; }
    else if(shoe.lastHand.res==='B'){ dr.innerText=`BANKER WIN ‚Äî P:${shoe.lastHand.p} vs B:${shoe.lastHand.b}`; dr.style.color='#e74c3c'; }
    else { dr.innerText=`TIE ‚Äî P:${shoe.lastHand.p} vs B:${shoe.lastHand.b}`; dr.style.color='#27ae60'; }
  }else dealArea.style.display='none';
}
function onPenChange(){
  shoe.pen=parseInt(document.getElementById('shoe_pen').value)||60;
  if(document.getElementById('rng_method').value==='shoe') initShoe(true);
  refreshShoeUI();
}
function onRngChange(){
  const m=document.getElementById('rng_method').value;
  const ui=document.getElementById('shoe_ui');
  if(m==='shoe'){
    ui.classList.add('active');
    initShoe(false);
    refreshShoeUI();
  }else ui.classList.remove('active');
}

/* =========================
   Core + 3 Modes
   ========================= */
const UNDO_STACK_LIMIT = 500;
const DEFAULT_DIVISOR = 2.0;
const MODES = { LEGACY:'legacy', KCAP_A:'kcapA', KCAP_B:'kcapB' };
const KCAP_MODES = new Set([MODES.KCAP_A, MODES.KCAP_B]);

const FIRST_LOSS_TIERS = {
  low:  { div: 2.0, capPct: 0.35 },
  mid:  { div: 2.0, capPct: 0.50 },
  high: { div: 2.0, capPct: 0.66 }
};
function getFirstLossTier(){ return document.getElementById('first_loss_tier')?.value || 'low'; }

let enabledModes = { legacy:true, kcapA:true, kcapB:true };
function modeEnabled(modeKey){ return !!enabledModes[modeKey]; }
function anyModeEnabled(){ return modeEnabled(MODES.LEGACY) || modeEnabled(MODES.KCAP_A) || modeEnabled(MODES.KCAP_B); }
function firstEnabledModeKey(){
  if(modeEnabled(MODES.KCAP_A)) return MODES.KCAP_A;
  if(modeEnabled(MODES.KCAP_B)) return MODES.KCAP_B;
  if(modeEnabled(MODES.LEGACY)) return MODES.LEGACY;
  return MODES.LEGACY;
}
function toggleMode(uiKey){
  enabledModes[uiKey] = !enabledModes[uiKey];
  if(!anyModeEnabled()){
    enabledModes[uiKey] = true;
    alert("‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡πÇ‡∏´‡∏°‡∏î");
  }
  const dm = displayMode();
  if(!modeEnabled(dm)) setDisplayMode(firstEnabledModeKey());
  updateModeButtonsUI();
  updateUI();
}
function updateModeButtonsUI(){
  const map = [
    {k:'legacy', btn:'btn_mode_legacy', lb:'lbl_mode_legacy'},
    {k:'kcapA',  btn:'btn_mode_kcapA',  lb:'lbl_mode_kcapA'},
    {k:'kcapB',  btn:'btn_mode_kcapB',  lb:'lbl_mode_kcapB'}
  ];
  map.forEach(x=>{
    const on = !!enabledModes[x.k];
    const b = document.getElementById(x.btn);
    const l = document.getElementById(x.lb);
    if(b){ b.classList.toggle('on', on); b.classList.toggle('off', !on); }
    if(l) l.textContent = on ? 'ON' : 'OFF';
  });
}

let undoStack=[];
let chartInstance=null;
let isAutoRunning=false;
let simRoundCount=0;
let simSuccessCount=0;
let autoTimer=null;

let cycleHistoryByMode = { legacy:[], kcapA:[], kcapB:[] };
let cycleNoByMode = { legacy:1, kcapA:1, kcapB:1 };
let cycleStartTsByMode = { legacy:Date.now(), kcapA:Date.now(), kcapB:Date.now() };

let state={ history:[], roadAll:[] };

function getBankroll(){ return parseFloat(document.getElementById('init_bank').value)||0; }
function getMinBet(){ return parseFloat(document.getElementById('min_bet').value)||0; }
function getChip(){ return parseFloat(document.getElementById('chip_size').value)||1; }

function getKellyScale(){
  const v = parseFloat(document.getElementById('kelly_scale')?.value || '1');
  if(!Number.isFinite(v)) return 1.0;
  return Math.max(0, Math.min(1, v));
}
function getKcapMaxPct(){
  const v = parseFloat(document.getElementById('kcap_max_pct')?.value || '0');
  if(!Number.isFinite(v)) return 0;
  return Math.max(0, v);
}

function saveState(){
  undoStack.push({
    state: JSON.parse(JSON.stringify(state)),
    shoe: JSON.parse(JSON.stringify(shoe)),
    modes: JSON.parse(JSON.stringify(modes)),
    lifetimeModes: JSON.parse(JSON.stringify(lifetimeModes)),
    modeGraph: JSON.parse(JSON.stringify(modeGraph)),
    enabledModes: JSON.parse(JSON.stringify(enabledModes)),
    cycleHistoryByMode: JSON.parse(JSON.stringify(cycleHistoryByMode)),
    cycleNoByMode: JSON.parse(JSON.stringify(cycleNoByMode)),
    cycleStartTsByMode: JSON.parse(JSON.stringify(cycleStartTsByMode)),
    simRoundCount, simSuccessCount
  });
  if(undoStack.length > UNDO_STACK_LIMIT) undoStack.shift();
}
function undo(){
  if(undoStack.length===0) return;
  const snap=undoStack.pop();
  state=snap.state;
  shoe=snap.shoe || shoe;
  modes=snap.modes || modes;
  lifetimeModes=snap.lifetimeModes || lifetimeModes;
  modeGraph=snap.modeGraph || modeGraph;
  enabledModes=snap.enabledModes || enabledModes;
  cycleHistoryByMode=snap.cycleHistoryByMode || cycleHistoryByMode;
  cycleNoByMode=snap.cycleNoByMode || cycleNoByMode;
  cycleStartTsByMode=snap.cycleStartTsByMode || cycleStartTsByMode;
  simRoundCount=snap.simRoundCount || 0;
  simSuccessCount=snap.simSuccessCount || 0;
  updateModeButtonsUI();
  updateUI();
}

function roundToChip(val){
  const chip=getChip();
  const min=getMinBet();
  if(!Number.isFinite(val) || val<=0) return 0;
  const rounded=Math.ceil(val/chip)*chip;
  return Math.max(min, rounded);
}

function dynamicTargetEnabled(){ return !!document.getElementById('use_dynamic_target')?.checked; }
function targetPct(){ return Math.max(0, parseFloat(document.getElementById('target_pct')?.value || '1') || 0); }
function fixedTargetProfit(){ return parseFloat(document.getElementById('target_profit')?.value || '0') || 0; }

const SPECIAL_DYNAMIC_TARGET_PCT = 0.05;
const SPECIAL_LIFETIME_PROFIT_MIN = 1000;

function freshLifetime(){ return { net:0, comm:0, maxBet:0, highWater:0, maxDrawdown:0 }; }
let lifetimeModes = { legacy:freshLifetime(), kcapA:freshLifetime(), kcapB:freshLifetime() };
function lifetimeEquityOf(lf){ return (lf.net||0) + (lf.comm||0); }
function lifetimeNetPlusComm(modeKey){
  const lf = lifetimeModes?.[modeKey];
  if(!lf) return 0;
  return lifetimeEquityOf(lf);
}
function specialDynamicTargetActive_ByModeKey(modeKey){
  if(!dynamicTargetEnabled()) return false;
  if(!modeEnabled(modeKey)) return false;
  const lp = lifetimeNetPlusComm(modeKey);
  return (lp > 0) && (lp >= SPECIAL_LIFETIME_PROFIT_MIN);
}
function effectiveTargetPct_ByModeKey(modeKey){
  return specialDynamicTargetActive_ByModeKey(modeKey) ? SPECIAL_DYNAMIC_TARGET_PCT : targetPct();
}

function xIsActive_Mode(modeKey){
  const m = modes[modeKey];
  if(!m) return false;
  const triggerHands=parseInt(document.getElementById('x_live_hands_on_trigger').value)||13;
  const source=document.getElementById('x_count_source').value || 'include_virtual';
  const seen = (source==='live_only') ? (m.commHands||0) : (state.history.length||0);
  return seen >= triggerHands;
}
function xTargetMultiplier_Mode(modeKey){
  if(!xIsActive_Mode(modeKey)) return 1.0;
  const t=parseFloat(document.getElementById('x_times_target').value)||1;
  return Math.max(1, t);
}

function survivalEnabled(){ return !!document.getElementById('enable_survival')?.checked; }
function calculateDivisor(deficit, minBet){
  let baseDiv=DEFAULT_DIVISOR;
  if(survivalEnabled()){
    const survMult=parseFloat(document.getElementById('surv_div').value)||1.85;
    baseDiv*=survMult;
    document.getElementById('survival_box').classList.add('survival-active');
  }else document.getElementById('survival_box').classList.remove('survival-active');
  if(deficit>500*minBet) baseDiv-=0.1;
  if(deficit>2000*minBet) baseDiv-=0.1;
  if(deficit>5000*minBet) baseDiv-=0.1;
  if(baseDiv<1.5) baseDiv=1.5;
  return baseDiv;
}

function baseBetFromDeficit(deficit, minBet, consLoss=0){
  if(!(deficit > 0)) return minBet;
  let div = calculateDivisor(deficit, minBet);
  const cl = Math.min(200, Math.max(0, consLoss||0));
  div = div * Math.pow(1.04, cl);
  let bet = (deficit + minBet) / div;
  bet = roundToChip(bet);
  return Math.max(minBet, bet);
}

function freshModeState(){
  return {
    realBalance:0, commTotal:0, equityHigh:0, maxDDEquity:0,
    noBetStreak:0, maxBet:0, cycleStartBalance:0,
    commTurnover:0, commHands:0, commTotalStart:0,
    cycleHands:0,
    staker:{bal:0,wait:1,stage:0,initBet:0,cons_loss:0, equity_high_cycle:0},
    pStrat:{bal:0,wait:1,stage:0,initBet:0,cons_loss:0},
    bStrat:{bal:0,wait:1,stage:0,initBet:0,cons_loss:0},
    lastNet:{side:'WAIT', strength:0, p:0, b:0, p_cnt:0, b_cnt:0},
    xState:{ lastOutcome:null, stopArmed:false }
  };
}
let modes = { legacy:freshModeState(), kcapA:freshModeState(), kcapB:freshModeState() };

function modeEquity(m){ return (m.realBalance||0) + (m.commTotal||0); }
function modeBankrollLeft(m){ return getBankroll() + modeEquity(m); }
function modeCycleProfit(m){ return (m.realBalance||0) - (m.cycleStartBalance||0); }

function getEffectiveTargetProfit_Mode(modeKey){
  const m = modes[modeKey];
  if(!m) return 0;
  const minBet = getMinBet();
  const chip = getChip();
  if(!dynamicTargetEnabled()) return Math.max(0, fixedTargetProfit());
  const left = modeBankrollLeft(m);
  const pct = effectiveTargetPct_ByModeKey(modeKey) / 100;
  const raw = left * pct;
  const rounded = Math.ceil(raw / chip) * chip;
  return Math.max(minBet, rounded);
}

function signalSource(){ return document.getElementById('signal_source')?.value || 'per_mode'; }
function kellyPSource(){ return document.getElementById('kelly_p_source')?.value || 'logistic'; }
function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

function displayMode(){ return document.getElementById('display_mode')?.value || 'legacy'; }
function displayModeKey(){
  const dm = displayMode();
  if(dm === 'kcapA') return MODES.KCAP_A;
  if(dm === 'kcapB') return MODES.KCAP_B;
  return MODES.LEGACY;
}
function setDisplayMode(v){
  const sel = document.getElementById('display_mode');
  if(sel) sel.value = v;
  updateUI();
}
function highlightCompareCards(){
  const dm = displayMode();
  ['legacy','kcapA','kcapB'].forEach(k=>{
    const el = document.getElementById('mm_card_'+k);
    if(!el) return;
    el.classList.toggle('mm-selected', dm===k);
    el.style.opacity = modeEnabled(k) ? '1' : '0.45';
  });
}

function updateLifetimeMode(modeKey, netDelta, commAdded, bet){
  const lf = lifetimeModes[modeKey];
  if(!lf) return;
  lf.net += (netDelta||0);
  lf.comm += (commAdded||0);
  if((bet||0) > (lf.maxBet||0)) lf.maxBet = bet||0;
  const eq = lifetimeEquityOf(lf);
  if(eq > (lf.highWater||0)) lf.highWater = eq;
  const dd = eq - (lf.highWater||0);
  if(dd < (lf.maxDrawdown||0)) lf.maxDrawdown = dd;
}

let modeGraph = {
  legacy: { labels:[0], data:[0] },
  kcapA:  { labels:[0], data:[0] },
  kcapB:  { labels:[0], data:[0] }
};
function resetModeGraphOne(modeKey){ modeGraph[modeKey] = { labels:[0], data:[0] }; }

function pFromStrength_Logistic(strength){
  const minStrength = parseFloat(document.getElementById('min_strength').value)||1;
  const pCap = parseFloat(document.getElementById('p_cap').value)||0.54;
  const edgeMax = parseFloat(document.getElementById('edge_max').value)||0.04;
  const k = parseFloat(document.getElementById('p_log_k').value)||0.35;
  if(!(strength >= minStrength)) return 0.5;
  const s = strength - minStrength;
  const edge = edgeMax * (1 - Math.exp(-k * s));
  return clamp(0.5 + edge, 0.5, pCap);
}
function pFixedForSide(side){
  const pP = parseFloat(document.getElementById('p_fixed_p').value)||0.51;
  const pB = parseFloat(document.getElementById('p_fixed_b').value)||0.50;
  return clamp((side==='B') ? pB : pP, 0.001, 0.999);
}
function kellyP(side, strength){
  return (kellyPSource()==='fixed') ? pFixedForSide(side) : pFromStrength_Logistic(strength);
}
function kellyFraction(p, b){
  const q = 1 - p;
  const f = (b*p - q) / b;
  return Math.max(0, f);
}
function kellyBetFull(bankrollLeft, side, strength){
  const b = (side==='B') ? 0.95 : 1.0;
  const p = kellyP(side, strength);
  const f = kellyFraction(p, b);
  return bankrollLeft * f;
}

const KCAP_LOSS_ADD_PCT = 0.0005;
const KCAP_LOSS_ADD_CAP_PCT_OF_DEFICIT = 0.25;
function kcapLossBaseAdd(modeKey, deficit){
  const m = modes?.[modeKey];
  const minBet = getMinBet();
  const chip = getChip();
  const left = m ? modeBankrollLeft(m) : getBankroll();
  let baseAddRaw = left * KCAP_LOSS_ADD_PCT;
  if(Number.isFinite(deficit) && deficit > 0 && KCAP_LOSS_ADD_CAP_PCT_OF_DEFICIT > 0){
    baseAddRaw = Math.min(baseAddRaw, deficit * KCAP_LOSS_ADD_CAP_PCT_OF_DEFICIT);
  }
  const rounded = Math.ceil(baseAddRaw / chip) * chip;
  return Math.max(minBet, rounded);
}

function lastNonTie(){
  for(let i=state.history.length-1;i>=0;i--){
    const x=state.history[i];
    if(x==='P' || x==='B') return x;
  }
  return null;
}
function getRawBet(strat){
  const minBet=getMinBet();
  const maxBetCap=parseFloat(document.getElementById('max_bet_cap').value)||0;
  let bet=0;
  if(strat.stage > 30) strat.stage = 30;
  if(strat.stage>=1){
    bet=strat.initBet*Math.pow(2, Math.max(0, strat.stage-1));
  }else if(strat.wait>=1){
    const deficit=Math.abs(strat.bal);
    if(deficit>0){
      let div=calculateDivisor(deficit,minBet);
      const cl = Math.min(200, (strat.cons_loss||0));
      div=div*Math.pow(1.04, cl);
      bet=(div<=0)?0:((deficit+minBet)/div);
    }else bet=minBet;
  }
  if(!Number.isFinite(bet) || bet<=0) return 0;
  bet = roundToChip(bet);
  if(maxBetCap>0) bet = Math.min(bet, maxBetCap);
  return bet;
}

const TRAINED_POLICY = {
  wP: { c:-0.3928252531634952, bias:0.8708993699161368, zig:0.9898610254061753, tieRate:-0.3955203431275083, streakN:-0.13981681295704762, lastP:0.2532830015248164, lastB:0.07488143904492145 },
  wB: { c:-1.1508993524052586, bias:-0.4321370196771435, zig:-0.9614563873601566, tieRate:0.2576827616572196, streakN:-0.41800751134256997, lastP:0.24814946837852042, lastB:0.3477249348305153 },
  wW: { c:-0.5528507363362684, bias:1.3951764069146138, zig:-0.16996934097562105, tieRate:-1.1134453873209744, streakN:1.0447036802114804, lastP:0.5488793440369264, lastB:1.0476893375084022 }
};
function _dot(w, f){ return (w.c||0)*(f.c||0)+(w.bias||0)*(f.bias||0)+(w.zig||0)*(f.zig||0)+(w.tieRate||0)*(f.tieRate||0)+(w.streakN||0)*(f.streakN||0)+(w.lastP||0)*(f.lastP||0)+(w.lastB||0)*(f.lastB||0); }
function _computePolicyFeatures(){
  const h = state.history || [];
  const N = h.length;
  const W = Math.min(30, N);
  const slice = h.slice(-W);
  const last = (N > 0) ? h[N-1] : null;
  const lastP = (last === 'P') ? 1 : 0;
  const lastB = (last === 'B') ? 1 : 0;
  let streak = (N > 0) ? 1 : 0;
  if(N >= 2){ for(let i=N-2;i>=0;i--){ if(h[i] === last) streak++; else break; } }
  const streakN = (N===0) ? 0 : Math.min(1, Math.log(1+streak) / Math.log(1+15));
  let zigCnt = 0;
  for(let i=0;i<slice.length-1;i++) if(slice[i] !== slice[i+1]) zigCnt++;
  const zig = (slice.length <= 1) ? 0 : zigCnt/(slice.length-1);
  let ties = 0;
  for(const r of slice) if(r === 'T') ties++;
  const tieRate = (slice.length === 0) ? 0 : ties/slice.length;
  let p=0, b=0;
  for(const r of slice){ if(r === 'P') p++; else if(r === 'B') b++; }
  const denom = p+b;
  const bias = (denom === 0) ? 0 : (p-b)/denom;
  return { c:1, bias, zig, tieRate, streakN, lastP, lastB };
}
function policyVote(){
  const f=_computePolicyFeatures();
  const LP=_dot(TRAINED_POLICY.wP,f);
  const LB=_dot(TRAINED_POLICY.wB,f);
  const LW=_dot(TRAINED_POLICY.wW,f);
  let action='WAIT';
  let best=LW;
  if(LP>best){ best=LP; action='P'; }
  if(LB>best){ best=LB; action='B'; }
  const w=parseFloat(document.getElementById('w_policy_ai').value)||1;
  return { side: action, w };
}
function voteOffsetFrom(pStrat, bStrat){
  const w=parseFloat(document.getElementById('w_offset').value)||1;
  const rawP=getRawBet(pStrat);
  const rawB=getRawBet(bStrat);
  if(rawP===0 && rawB===0) return {side:'WAIT', w:0};
  if(rawP>rawB) return {side:'P', w};
  if(rawB>rawP) return {side:'B', w};
  return {side:'WAIT', w:0};
}
function voteSomethingElseFrom(pStrat, bStrat){
  const w=parseFloat(document.getElementById('w_something_else').value)||1;
  const rawP=getRawBet(pStrat);
  const rawB=getRawBet(bStrat);
  const diff=Math.abs(rawP-rawB);
  const threshold=Math.max(getMinBet(), 2*getChip());
  if(rawP===0 && rawB===0) return {side:'WAIT', w:0};
  if(diff<=threshold) return {side:'B', w};
  if(rawP>rawB) return {side:'P', w};
  if(rawB>rawP) return {side:'B', w};
  return {side:'WAIT', w:0};
}
function voteAntiLast(){
  const last=lastNonTie();
  if(!last) return {side:'WAIT', w:0};
  const w=parseFloat(document.getElementById('w_anti_last').value)||1;
  return {side:(last==='P'?'B':'P'), w};
}
function voteFollowLast(){
  const last=lastNonTie();
  if(!last) return {side:'WAIT', w:0};
  const w=parseFloat(document.getElementById('w_follow_last').value)||1;
  return {side:last, w};
}
function netVotesLocal(votes){
  const mode=document.getElementById('net_mode').value;
  const minStrength=parseFloat(document.getElementById('min_strength').value)||1.0;
  let p=0, b=0, p_cnt=0, b_cnt=0;
  for(const v of votes){
    const side=v.side;
    const w=Math.max(0, Number(v.w||0));
    if(side==='P'){ p_cnt++; p += (mode==='count') ? 1 : w; }
    else if(side==='B'){ b_cnt++; b += (mode==='count') ? 1 : w; }
  }
  const strength=Math.abs(p-b);
  let side='WAIT';
  if(strength>=minStrength && p!==b) side = (p>b) ? 'P' : 'B';
  return {side, strength, p, b, p_cnt, b_cnt};
}
function strengthMultiplier(strength){
  if(strength <= 0) return 0.0;
  if(strength < 2.0) return 1.0;
  if(strength < 3.0) return 1.3;
  if(strength < 4.0) return 1.6;
  return 2.0;
}
function getVotesForMode(m){
  const votes=[];
  if(document.getElementById('use_offset').checked) votes.push(voteOffsetFrom(m.pStrat, m.bStrat));
  if(document.getElementById('use_anti_last').checked) votes.push(voteAntiLast());
  if(document.getElementById('use_follow_last').checked) votes.push(voteFollowLast());
  if(document.getElementById('use_something_else').checked) votes.push(voteSomethingElseFrom(m.pStrat, m.bStrat));
  if(document.getElementById('use_policy_ai').checked) votes.push(policyVote());
  return votes;
}
function computeSignalForMode(modeKey){
  const m=modes[modeKey];
  const votes=getVotesForMode(m);
  const net=netVotesLocal(votes);
  m.lastNet = net;
  return { side: net.side, strength: net.strength };
}
// shared = ‡πÉ‡∏ä‡πâ LEGACY ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á ‡πÅ‡∏•‡πâ‡∏ß copy ‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á 3 ‡πÇ‡∏´‡∏°‡∏î (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£)
function computeSignalShared(){
  const tmpVotes=[];
  const m0 = modes[MODES.LEGACY];
  if(document.getElementById('use_offset').checked) tmpVotes.push(voteOffsetFrom(m0.pStrat, m0.bStrat));
  if(document.getElementById('use_anti_last').checked) tmpVotes.push(voteAntiLast());
  if(document.getElementById('use_follow_last').checked) tmpVotes.push(voteFollowLast());
  if(document.getElementById('use_something_else').checked) tmpVotes.push(voteSomethingElseFrom(m0.pStrat, m0.bStrat));
  if(document.getElementById('use_policy_ai').checked) tmpVotes.push(policyVote());
  const net=netVotesLocal(tmpVotes);
  modes[MODES.LEGACY].lastNet = JSON.parse(JSON.stringify(net));
  modes[MODES.KCAP_A].lastNet = JSON.parse(JSON.stringify(net));
  modes[MODES.KCAP_B].lastNet = JSON.parse(JSON.stringify(net));
  return { side: net.side, strength: net.strength };
}

function resetStaker_Mode(m){ m.staker = {bal:0,wait:1,stage:0,initBet:0,cons_loss:0, equity_high_cycle:0}; }
function resetDualEngines_Mode(m){
  m.pStrat={bal:0,wait:1,stage:0,initBet:0,cons_loss:0};
  m.bStrat={bal:0,wait:1,stage:0,initBet:0,cons_loss:0};
}

function applyKellyRiskCaps_KCAP(modeKey, bet){
  if(!Number.isFinite(bet) || bet<=0) return 0;
  const m = modes[modeKey];
  if(!m) return 0;
  if(modeCycleProfit(m) < 0) return bet; // disable caps when cycle loss
  let out = bet;
  out = out * getKellyScale();
  const pct = getKcapMaxPct();
  if(pct > 0){
    const left = modeBankrollLeft(m);
    const chip = getChip();
    const minBet = getMinBet();
    const capRaw = left * (pct/100);
    const capRounded = Math.floor(capRaw / chip) * chip;
    const capFinal = Math.max(0, capRounded);
    out = Math.min(out, capFinal);
    if(out > 0 && out < minBet) return 0;
  }
  return out;
}

function capBetToModeBankrollHard(modeKey, bet){
  const m = modes[modeKey];
  if(!m) return 0;
  if(!Number.isFinite(bet) || bet<=0) return 0;
  const left = modeBankrollLeft(m);
  const chip = getChip();
  const minBet = getMinBet();
  if(left <= 0) return 0;
  const capped = Math.floor(Math.min(bet, left) / chip) * chip;
  if(capped < minBet) return 0;
  return capped;
}
function capBetToModeBankroll(modeKey, bet){
  return capBetToModeBankrollHard(modeKey, bet);
}

function applyTargetSniper_Mode(modeKey, bet, side){
  const m = modes[modeKey];
  if(!m) return bet;
  const targetProfit = getEffectiveTargetProfit_Mode(modeKey);
  if(targetProfit<=0) return bet;
  if(bet<=0) return bet;
  const cp = modeCycleProfit(m);
  const neededProfit = targetProfit - cp;
  if(neededProfit <= 0) return 0;
  const chip = getChip();
  const minBet = getMinBet();
  const minProfitThisSide = (side === 'B') ? (minBet * 0.95) : minBet;
  if(neededProfit < minProfitThisSide) return 0;
  let reqBet = neededProfit;
  if(side === 'B') reqBet = neededProfit / 0.95;
  const adj = Math.floor(reqBet / chip) * chip;
  if(adj < minBet) return 0;
  return Math.min(bet, adj);
}

function xBetMultiplier_Mode(modeKey){
  const m=modes[modeKey];
  if(!m) return 1.0;
  if(!xIsActive_Mode(modeKey)) return 1.0;
  const pass=parseFloat(document.getElementById('x_mult_pass').value)||1;
  const fail=parseFloat(document.getElementById('x_mult_fail').value)||1;
  if(m.xState.lastOutcome==='WIN') return pass;
  if(m.xState.lastOutcome==='LOSS') return fail;
  return fail;
}
function xShouldForceWaitAfterPass_Mode(modeKey){
  const m=modes[modeKey];
  if(!m) return false;
  const rule = document.getElementById('x_rule_mode').value || 'C_multiplier';
  const stopOnPass = !!document.getElementById('x_stop_on_pass').checked;
  if(!xIsActive_Mode(modeKey)) return false;
  if(rule !== 'D_stop') return false;
  if(!stopOnPass) return false;
  if(m.xState.stopArmed === true){
    m.xState.stopArmed = false;
    return true;
  }
  return false;
}

// base bet per mode:
// - LEGACY: default
// - KCAP_A: First Loss Tier hook
// - KCAP_B: loss-base-add + cp<0 => baseBetFromDeficit only
function stakerProposeBaseBet_Mode(modeKey, m){
  const s = m.staker;
  const minBet = getMinBet();
  if(s.stage > 30) s.stage = 30;
  const maxBetCap = parseFloat(document.getElementById('max_bet_cap').value) || 0;

  if(modeKey === MODES.LEGACY){
    let bet = 0;
    if(s.stage >= 1){
      bet = s.initBet * Math.pow(2, Math.max(0, s.stage - 1));
    }else if(s.wait >= 1){
      const deficit = Math.abs(s.bal);
      if(deficit > 0){
        let div = calculateDivisor(deficit, minBet);
        const cl = Math.min(200, Math.max(0, s.cons_loss || 0));
        div = div * Math.pow(1.04, cl);
        bet = (div <= 0) ? 0 : ((deficit + minBet) / div);
      }else bet = minBet;
    }
    if(!Number.isFinite(bet) || bet<=0) return 0;
    bet = roundToChip(bet);
    if(maxBetCap > 0) bet = Math.min(bet, maxBetCap);
    return bet;
  }

  if(modeKey === MODES.KCAP_B){
    const cp = modeCycleProfit(m);
    if(cp < 0){
      const deficitCycle = -cp;
      let bet = baseBetFromDeficit(deficitCycle, minBet, s.cons_loss);
      if(maxBetCap > 0) bet = Math.min(bet, maxBetCap);
      return bet;
    }
    let bet=0;
    if(s.stage>=1){
      bet = s.initBet * Math.pow(2, Math.max(0, s.stage-1));
    }else if(s.wait>=1){
      const deficit=Math.abs(s.bal);
      if(deficit>0){
        let div=calculateDivisor(deficit,minBet);
        const cl = Math.min(200, (s.cons_loss||0));
        div=div*Math.pow(1.04, cl);
        const add = kcapLossBaseAdd(modeKey, deficit);
        bet=(div<=0)?0:((deficit+add)/div);
      }else bet=minBet;
    }
    if(!Number.isFinite(bet) || bet<=0) return 0;
    bet = roundToChip(bet);
    if(maxBetCap>0) bet = Math.min(bet, maxBetCap);
    return bet;
  }

  // KCAP_A
  let bet = 0;
  if(s.stage >= 1){
    bet = s.initBet * Math.pow(2, Math.max(0, s.stage - 1));
  }else if(s.wait >= 1){
    const deficit = Math.abs(s.bal);
    if((s.stage || 0) === 0){
      if(deficit <= 0){
        bet = minBet;
      }else{
        const tierKey = getFirstLossTier();
        const tier = FIRST_LOSS_TIERS[tierKey] || FIRST_LOSS_TIERS.low;
        bet = Math.max(minBet, deficit / tier.div);
        bet = Math.min(bet, deficit * tier.capPct);
      }
    }else{
      if(deficit > 0){
        let div = calculateDivisor(deficit, minBet);
        const cl = Math.min(200, Math.max(0, s.cons_loss || 0));
        div = div * Math.pow(1.04, cl);
        bet = (div <= 0) ? 0 : ((deficit + minBet) / div);
      }else bet = minBet;
    }
  }
  if(!Number.isFinite(bet) || bet<=0) return 0;
  bet = roundToChip(bet);
  if(maxBetCap>0) bet = Math.min(bet, maxBetCap);
  return bet;
}

function updateAI(strat, side, res, rawBet){
  if(res==='T') return;
  const isWin=(side==='P'&&res==='P')||(side==='B'&&res==='B');
  if(isWin){
    strat.wait++; strat.cons_loss=0;
    strat.bal += (side==='P') ? rawBet : (rawBet*0.95);
    if(rawBet>0){
      if(strat.stage===0){ strat.initBet=rawBet; strat.stage=1; }
      else strat.stage = Math.min((strat.stage||0)+1, 30);
    }
  }else{
    strat.wait=0;
    strat.cons_loss=(strat.cons_loss||0)+1;
    if(rawBet>0){ strat.bal-=rawBet; strat.stage=0; }
  }
}
function stakerUpdateOnResult_Mode(m, netSide, bet, res){
  const s=m.staker;
  const cp=modeCycleProfit(m);
  if(cp > (s.equity_high_cycle||0)) s.equity_high_cycle = cp;
  if(bet<=0 || netSide==='WAIT') return;
  if(res==='T') return;
  const isWin = (netSide==='P' && res==='P') || (netSide==='B' && res==='B');
  if(isWin){
    s.wait = Math.max(1, (s.wait||0) + 1);
    s.cons_loss=0;
    const profit = (netSide==='B') ? (bet*0.95) : bet;
    s.bal += profit;
    if(s.stage===0){ s.initBet=bet; s.stage=1; }
    else s.stage = Math.min(30, (s.stage||0)+1);
  }else{
    s.wait = 1;
    s.cons_loss=(s.cons_loss||0)+1;
    s.bal -= bet;
    s.stage=0;
  }
}

function applyCommission_Mode(modeKey, bet, res){
  const m=modes[modeKey];
  if(!m) return 0;
  if(bet<=0) return 0;
  if(res==='T') return 0;
  const commRate=parseFloat(document.getElementById('commission_rate').value)||0;
  m.commTurnover += bet;
  m.commHands += 1;
  const comm = (commRate>0) ? bet*(commRate/100) : 0;
  m.commTotal += comm;
  return comm;
}
function settleBet(side, bet, res){
  if(bet<=0 || side==='WAIT') return 0;
  if(res==='T') return 0;
  if(side==='P') return (res==='P') ? bet : -bet;
  if(side==='B') return (res==='B') ? (bet*0.95) : -bet;
  return 0;
}

function computeRecForMode(modeKey, signal){
  const m = modes[modeKey];
  if(!modeEnabled(modeKey) || !m) return {side:'WAIT', bet:0};
  const side = (signal.side==='P' || signal.side==='B') ? signal.side : 'WAIT';
  if(side==='WAIT') return {side:'WAIT', bet:0};
  const maxBetCap=parseFloat(document.getElementById('max_bet_cap').value)||0;

  const base = stakerProposeBaseBet_Mode(modeKey, m);
  const mult = strengthMultiplier(signal.strength);
  let legacyBet = roundToChip(base * mult);

  legacyBet = applyTargetSniper_Mode(modeKey, legacyBet, side);
  if(document.getElementById('require_both_x').checked){
    if(xShouldForceWaitAfterPass_Mode(modeKey)) legacyBet = 0;
    else legacyBet = roundToChip(legacyBet * xBetMultiplier_Mode(modeKey));
  }
  if(maxBetCap>0) legacyBet = Math.min(legacyBet, maxBetCap);
  legacyBet = capBetToModeBankroll(modeKey, legacyBet);
  if(legacyBet<=0) return {side:'WAIT', bet:0};

  if(KCAP_MODES.has(modeKey)){
    let kbet = kellyBetFull(modeBankrollLeft(m), side, signal.strength);
    kbet = roundToChip(kbet);
    kbet = applyKellyRiskCaps_KCAP(modeKey, kbet);
    kbet = roundToChip(kbet);

    kbet = applyTargetSniper_Mode(modeKey, kbet, side);
    if(document.getElementById('require_both_x').checked){
      if(xShouldForceWaitAfterPass_Mode(modeKey)) kbet = 0;
      else kbet = roundToChip(kbet * xBetMultiplier_Mode(modeKey));
    }

    if(maxBetCap>0) kbet = Math.min(kbet, maxBetCap);
    kbet = capBetToModeBankroll(modeKey, kbet);
    const bet = Math.min(legacyBet||0, kbet||0);
    if(bet<=0) return {side:'WAIT', bet:0};
    return {side, bet};
  }

  return {side, bet: legacyBet};
}

function settleOneMode(modeKey, rec, res){
  if(!modeEnabled(modeKey)) return;
  const m=modes[modeKey];
  if(!m) return;
  m.cycleHands = (m.cycleHands||0) + 1;
  const rawP=getRawBet(m.pStrat);
  const rawB=getRawBet(m.bStrat);
  const commAdded = applyCommission_Mode(modeKey, rec.bet, res);
  const netDelta  = settleBet(rec.side, rec.bet, res);
  m.realBalance += netDelta;
  const eqNow = modeEquity(m);
  if(eqNow > (m.equityHigh||0)) m.equityHigh = eqNow;
  const dd = eqNow - (m.equityHigh||0);
  if(dd < (m.maxDDEquity||0)) m.maxDDEquity = dd;
  stakerUpdateOnResult_Mode(m, rec.side, rec.bet, res);
  updateAI(m.pStrat,'P',res,rawP);
  updateAI(m.bStrat,'B',res,rawB);
  if(rec.bet > (m.maxBet||0)) m.maxBet = rec.bet;

  if(rec.bet>0 && rec.side!=='WAIT' && res!=='T'){
    const isWin = (rec.side==='P' && res==='P') || (rec.side==='B' && res==='B');
    m.xState.lastOutcome = isWin ? 'WIN' : 'LOSS';
    m.xState.stopArmed = isWin ? true : false;
  }

  if(rec.bet>0 && rec.side!=='WAIT' && res!=='T'){
    updateLifetimeMode(modeKey, netDelta, commAdded, rec.bet);
    const g = modeGraph[modeKey];
    if(g){
      const nextX = g.labels.length;
      g.labels.push(nextX);
      g.data.push(lifetimeEquityOf(lifetimeModes[modeKey]));
    }
  }
}

function modeCycleSummary(modeKey){
  const m = modes[modeKey];
  if(!m) return {cp:0,comm:0,netPlusComm:0,left:0,turnover:0,betHands:0,maxBet:0,dd:0,hands:0};
  const cp = modeCycleProfit(m);
  const commCycle = (m.commTotal||0) - (m.commTotalStart||0);
  const netPlusComm = cp + commCycle;
  const left = modeBankrollLeft(m);
  return { cp, comm:commCycle, netPlusComm, left, turnover:m.commTurnover||0, betHands:m.commHands||0, maxBet:m.maxBet||0, dd:m.maxDDEquity||0, hands:m.cycleHands||0 };
}
function resetCycle_Mode(modeKey, reason){
  const m = modes[modeKey];
  if(!m) return;
  const sum = modeCycleSummary(modeKey);
  cycleHistoryByMode[modeKey].push({ cycleNo: cycleNoByMode[modeKey], reason, tsStart: cycleStartTsByMode[modeKey], tsEnd: Date.now(), hands: sum.hands, summary: sum });
  cycleNoByMode[modeKey] += 1;
  cycleStartTsByMode[modeKey] = Date.now();
  m.cycleStartBalance = m.realBalance;
  m.commTotalStart = m.commTotal;
  m.commTurnover = 0;
  m.commHands = 0;
  m.maxBet = 0;
  m.noBetStreak = 0;
  m.cycleHands = 0;
  m.xState.lastOutcome = null;
  m.xState.stopArmed = false;
  resetStaker_Mode(m);
  resetDualEngines_Mode(m);
  simSuccessCount += 1;
}
function restartAfterBust_Mode(modeKey, reasonText){
  try{ resetCycle_Mode(modeKey, reasonText || "BUST"); }catch(e){}
  modes[modeKey] = freshModeState();
  lifetimeModes[modeKey] = freshLifetime();
  resetModeGraphOne(modeKey);
  cycleNoByMode[modeKey] = 1;
  cycleStartTsByMode[modeKey] = Date.now();
}
function checkBust_Mode(modeKey){
  const m=modes[modeKey];
  if(!m) return false;
  const left = modeBankrollLeft(m);
  const minBet = getMinBet();
  if(left<=0 || left<minBet){
    const reason = (left<=0) ? `BUST(${modeKey}): bankroll<=0` : `BUST(${modeKey}): bankroll<minBet`;
    restartAfterBust_Mode(modeKey, reason);
    return true;
  }
  return false;
}

function shouldAutoResetNearTarget_Mode(modeKey, plannedSide){
  const m = modes[modeKey];
  if(!m) return false;
  if(!(plannedSide === 'P' || plannedSide === 'B')) return false;
  const baseTarget = getEffectiveTargetProfit_Mode(modeKey);
  if(baseTarget <= 0) return false;
  const effTarget = baseTarget * xTargetMultiplier_Mode(modeKey);
  const cp = modeCycleProfit(m);
  const needed = effTarget - cp;
  if(needed <= 0) return false;
  const minBet = getMinBet();
  const minWin = (plannedSide === 'B') ? (minBet * 0.95) : minBet;
  return needed < minWin;
}

function processResultAll(res, isSim=false){
  try{
    if(!anyModeEnabled()){ alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡πÇ‡∏´‡∏°‡∏î"); return; }
    if(!isSim) saveState();

    let sigShared=null;
    if(signalSource()==='shared') sigShared = computeSignalShared();

    const sL = sigShared ? sigShared : computeSignalForMode(MODES.LEGACY);
    const sA = sigShared ? sigShared : computeSignalForMode(MODES.KCAP_A);
    const sB = sigShared ? sigShared : computeSignalForMode(MODES.KCAP_B);

    let rL = computeRecForMode(MODES.LEGACY, sL);
    let rA = computeRecForMode(MODES.KCAP_A, sA);
    let rB = computeRecForMode(MODES.KCAP_B, sB);

    // Near-target auto reset: ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ KCAP_B (‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô B)
    if(modeEnabled(MODES.KCAP_B) && shouldAutoResetNearTarget_Mode(MODES.KCAP_B, rB.side)){
      const m = modes[MODES.KCAP_B];
      const baseTarget = getEffectiveTargetProfit_Mode(MODES.KCAP_B);
      const effTarget  = baseTarget * xTargetMultiplier_Mode(MODES.KCAP_B);
      const cp = modeCycleProfit(m);
      const needed = effTarget - cp;
      const minWin = (rB.side==='B') ? (getMinBet()*0.95) : getMinBet();
      resetCycle_Mode(MODES.KCAP_B, `AUTO_RESET_NEAR_TARGET(kcapB): needed=${needed.toFixed(2)} < minWin=${minWin.toFixed(2)} | cp=${cp.toFixed(2)} / target=${effTarget.toFixed(2)}`);
      rB = {side:'WAIT', bet:0};
    }

    settleOneMode(MODES.LEGACY, rL, res);
    settleOneMode(MODES.KCAP_A, rA, res);
    settleOneMode(MODES.KCAP_B, rB, res);

    state.history.push(res);
    state.roadAll.push(res);

    for(const k of [MODES.LEGACY, MODES.KCAP_A, MODES.KCAP_B]){
      if(!modeEnabled(k)) continue;
      const m = modes[k];
      if(!m) continue;
      const baseTarget = getEffectiveTargetProfit_Mode(k);
      const effTarget = baseTarget * xTargetMultiplier_Mode(k);
      const cp = modeCycleProfit(m);
      if(baseTarget>0 && cp >= effTarget) resetCycle_Mode(k, `Target Reached (${k}) +${cp.toFixed(2)} / ${effTarget.toFixed(2)}`);
      const maxWait=parseInt(document.getElementById('max_wait_hands').value)||FIXED.MAX_WAIT_HANDS;
      if(maxWait>0 && (m.cycleHands||0) >= maxWait) resetCycle_Mode(k, `STALL(${k}): MAX_WAIT_HANDS=${maxWait}`);
      checkBust_Mode(k);
    }

    updateUI();
    if(!isSim) autosaveNow('manual-hand');
  }catch(err){
    console.error("processResultAll crashed:", err);
    try{ stopAutoSim(); }catch(e){}
    alert("‡πÄ‡∏Å‡∏¥‡∏î Error ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á:\n" + (err?.message || err));
  }
}

function renderBigRoad(){
  const roadDiv=document.getElementById('road_container');
  roadDiv.innerHTML='';
  let matrix=[], col=0, row=0, last=null;
  const setCell=(c,r,v)=>{ if(!matrix[c]) matrix[c]=[]; matrix[c][r]=v; };
  (state.roadAll || []).forEach(res=>{
    if(last===null){ setCell(col,row,res); last=res; return; }
    if(res===last){
      if(row<5 && (!matrix[col] || matrix[col][row+1]===undefined)) row++;
      else col++;
      setCell(col,row,res);
    }else{
      col++; row=0; setCell(col,row,res); last=res;
    }
  });
  const maxCol=matrix.length;
  const renderCols=Math.max(20,maxCol);
  for(let c=0;c<renderCols;c++){
    for(let r=0;r<6;r++){
      const cell=document.createElement('div');
      cell.className='big-road-cell';
      if(matrix[c] && matrix[c][r]){
        const v=matrix[c][r];
        const circle=document.createElement('div');
        circle.className=`circle circle-${v}`;
        circle.innerText=v;
        cell.appendChild(circle);
      }
      roadDiv.appendChild(cell);
    }
  }
  const wrapper=document.querySelector('.road-scroll-wrapper');
  if(wrapper){
    setTimeout(()=>{
      wrapper.scrollLeft=(maxCol*27)>wrapper.clientWidth ? (maxCol*27)-wrapper.clientWidth+50 : 0;
    },0);
  }
}

function renderSessionHistoryOne(modeKey){
  const body=document.getElementById('session_table_body_'+modeKey);
  if(!body) return;
  const hist = cycleHistoryByMode[modeKey] || [];
  if(hist.length===0){
    body.innerHTML=`<tr><td colspan="8" class="muted" style="padding:10px">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ</td></tr>`;
    return;
  }
  function clsSigned(x){ return (Number(x||0) >= 0) ? 'pos' : 'neg'; }
  body.innerHTML = hist.slice(-25).reverse().map(s=>{
    const sum = s.summary || {};
    const t=new Date(s.tsEnd);
    const timeStr=t.toLocaleString('th-TH',{hour12:false});
    const reason=String(s.reason||'').slice(0,22);
    return `
      <tr>
        <td>${s.cycleNo}</td>
        <td title="${s.reason}">${reason}</td>
        <td>${(s.hands||0)}</td>
        <td class="${clsSigned(sum.cp)}">${Number(sum.cp||0).toFixed(2)}</td>
        <td>${Number(sum.comm||0).toFixed(2)}</td>
        <td class="${clsSigned(sum.netPlusComm)}">${Number(sum.netPlusComm||0).toFixed(2)}</td>
        <td>${Number(sum.left||0).toFixed(2)}</td>
        <td class="muted">${timeStr}</td>
      </tr>
    `;
  }).join('');
}
function renderSessionHistoryAll(){ renderSessionHistoryOne('legacy'); renderSessionHistoryOne('kcapA'); renderSessionHistoryOne('kcapB'); }
function exportSessionHistoryAll(){
  const blob=new Blob([JSON.stringify(cycleHistoryByMode,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=`cycleHistoryByMode_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function clearSessionHistoryAll(){
  if(!confirm("‡∏•‡πâ‡∏≤‡∏á Cycle History ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏ó‡∏±‡πâ‡∏á 3 ‡πÇ‡∏´‡∏°‡∏î)?")) return;
  cycleHistoryByMode = { legacy:[], kcapA:[], kcapB:[] };
  renderSessionHistoryAll();
  updateUI();
  autosaveNow('clear-history');
}

function updateChart(){
  const ctx=document.getElementById('profitChart').getContext('2d');
  const GL = modeGraph[MODES.LEGACY] || {labels:[0],data:[0]};
  const GA = modeGraph[MODES.KCAP_A] || {labels:[0],data:[0]};
  const GB = modeGraph[MODES.KCAP_B] || {labels:[0],data:[0]};
  const labels =
    (GL.labels.length>=GA.labels.length && GL.labels.length>=GB.labels.length) ? GL.labels :
    (GA.labels.length>=GB.labels.length) ? GA.labels : GB.labels;
  const hiddenL = !modeEnabled(MODES.LEGACY);
  const hiddenA = !modeEnabled(MODES.KCAP_A);
  const hiddenB = !modeEnabled(MODES.KCAP_B);
  if(!chartInstance){
    chartInstance=new Chart(ctx,{
      type:'line',
      data:{ labels,
        datasets:[
          { label:'LEGACY (Lifetime Net+Comm)', data:GL.data, borderColor:'#2c3e50', borderWidth:2, fill:false, pointRadius:0, tension:0.1, hidden:hiddenL },
          { label:'KCAP_A (Lifetime Net+Comm)', data:GA.data, borderColor:getComputedStyle(document.documentElement).getPropertyValue('--kcapA').trim()||'#8e44ad', borderWidth:2, fill:false, pointRadius:0, tension:0.1, hidden:hiddenA },
          { label:'KCAP_B (Lifetime Net+Comm)', data:GB.data, borderColor:getComputedStyle(document.documentElement).getPropertyValue('--kcapB').trim()||'#e67e22', borderWidth:2, fill:false, pointRadius:0, tension:0.1, hidden:hiddenB }
        ]},
      options:{ responsive:true, maintainAspectRatio:false, animation:{duration:0}, plugins:{ legend:{display:true, position:'top'} }, scales:{ x:{display:false}, y:{grid:{color:'#f0f0f0'}} } }
    });
  }else{
    chartInstance.data.labels = labels;
    chartInstance.data.datasets[0].data = GL.data;
    chartInstance.data.datasets[1].data = GA.data;
    chartInstance.data.datasets[2].data = GB.data;
    chartInstance.data.datasets[0].hidden = hiddenL;
    chartInstance.data.datasets[1].hidden = hiddenA;
    chartInstance.data.datasets[2].hidden = hiddenB;
    chartInstance.update();
  }
}

function updateLifetimeUI(){
  const fmt2 = (x)=>Number(x||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  const fmt0 = (x)=>Number(x||0).toLocaleString(undefined,{maximumFractionDigits:0});
  const wrapSigned = (numStr, val)=>`<span class="${Number(val||0) >= 0 ? 'pos':'neg'}">${numStr}</span>`;
  const wrapPlain  = (numStr)=>`<span>${numStr}</span>`;
  const wrapOff = ()=>`<span class="muted">OFF</span>`;
  const join3 = (a,b,c)=>`${a} <span class="muted">/</span> ${b} <span class="muted">/</span> ${c}`;

  function cellSigned(modeKey, val){
    if(!modeEnabled(modeKey)) return wrapOff();
    return wrapSigned(fmt2(val), val);
  }
  function cellPlain(modeKey, val, digits){
    if(!modeEnabled(modeKey)) return wrapOff();
    if(digits===0) return wrapPlain(fmt0(val));
    return wrapPlain(fmt2(val));
  }

  const L=lifetimeModes[MODES.LEGACY]||freshLifetime();
  const A=lifetimeModes[MODES.KCAP_A]||freshLifetime();
  const B=lifetimeModes[MODES.KCAP_B]||freshLifetime();

  document.getElementById('all_net').innerHTML =
    join3(
      cellSigned(MODES.LEGACY, L.net),
      cellSigned(MODES.KCAP_A, A.net),
      cellSigned(MODES.KCAP_B, B.net)
    );
  document.getElementById('all_net_comm').innerHTML =
    join3(
      cellSigned(MODES.LEGACY, lifetimeEquityOf(L)),
      cellSigned(MODES.KCAP_A, lifetimeEquityOf(A)),
      cellSigned(MODES.KCAP_B, lifetimeEquityOf(B))
    );
  document.getElementById('all_max_dd').innerHTML =
    join3(
      cellSigned(MODES.LEGACY, L.maxDrawdown),
      cellSigned(MODES.KCAP_A, A.maxDrawdown),
      cellSigned(MODES.KCAP_B, B.maxDrawdown)
    );
  document.getElementById('all_max_bet').innerHTML =
    join3(
      cellPlain(MODES.LEGACY, L.maxBet, 0),
      cellPlain(MODES.KCAP_A, A.maxBet, 0),
      cellPlain(MODES.KCAP_B, B.maxBet, 0)
    );
}

function updateSpecialPill(modeKey, pillId, txtId, rtId, label){
  const on = specialDynamicTargetActive_ByModeKey(modeKey);
  const pill = document.getElementById(pillId);
  const txt  = document.getElementById(txtId);
  const rt   = document.getElementById(rtId);
  if(!pill || !txt || !rt) return;
  pill.classList.toggle('on', on);
  const lp = lifetimeNetPlusComm(modeKey);
  const pct = effectiveTargetPct_ByModeKey(modeKey);
  txt.textContent = on ? `${label}: Special ON` : `${label}: Special OFF`;
  rt.textContent = `Target%=${pct.toFixed(2)} | Life=${lp.toFixed(0)}`;
}

function updateUI(){
  updateModeButtonsUI();
  let dm = displayModeKey();
  if(!modeEnabled(dm)){
    dm = firstEnabledModeKey();
    const sel=document.getElementById('display_mode');
    if(sel) sel.value = dm;
  }
  updateSpecialPill(MODES.LEGACY, 'special_pill_legacy', 'special_txt_legacy', 'special_rt_legacy', 'LEGACY');
  updateSpecialPill(MODES.KCAP_A, 'special_pill_kcapA', 'special_txt_kcapA', 'special_rt_kcapA', 'KCAP_A');
  updateSpecialPill(MODES.KCAP_B, 'special_pill_kcapB', 'special_txt_kcapB', 'special_rt_kcapB', 'KCAP_B');

  let sig;
  if(signalSource()==='shared') sig = computeSignalShared();
  else sig = computeSignalForMode(dm);

  const recSel = computeRecForMode(dm, sig);
  document.getElementById('rec_amount').innerText = (recSel.bet||0).toLocaleString();
  let netSideLabel='WAIT', sideClass='side-n';
  if(recSel.side==='P'){ netSideLabel='PLAYER'; sideClass='side-p'; }
  else if(recSel.side==='B'){ netSideLabel='BANKER'; sideClass='side-b'; }
  document.getElementById('rec_side').innerText = netSideLabel;
  document.getElementById('rec_side').className = `rec-side ${sideClass}`;

  const baseTxt = (dm===MODES.LEGACY) ? 'LEGACY' : (dm===MODES.KCAP_A ? 'KCAP_A' : 'KCAP_B');
  document.getElementById('formula_disp').innerText =
    `${baseTxt} | signal=${signalSource()} | p_source=${kellyPSource()} | firstLoss=${getFirstLossTier()} | k_scale=${getKellyScale().toFixed(2)} | kcap_max%=${getKcapMaxPct().toFixed(2)}`;

  const m = modes[dm];
  const cp = modeCycleProfit(m);
  const hwm = m.staker.equity_high_cycle || 0;
  document.getElementById('target_status_display').innerText = `${cp.toFixed(2)} / ${hwm.toFixed(2)}`;

  const baseTarget = getEffectiveTargetProfit_Mode(dm);
  const effTarget = baseTarget * xTargetMultiplier_Mode(dm);
  document.getElementById('cycle_profit_disp').innerText = `${cp.toFixed(2)} / ${effTarget.toFixed(2)}`;

  const profitElem=document.getElementById('disp_net');
  profitElem.innerText=cp.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  profitElem.style.color=cp>=0?'var(--success)':'var(--danger)';

  const commCycle = (m.commTotal||0) - (m.commTotalStart||0);
  const eqCycle = cp + commCycle;
  document.getElementById('disp_net_comm').innerText = eqCycle.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  document.getElementById('disp_comm_total').innerText = commCycle.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  document.getElementById('disp_dd').innerText=(m.maxDDEquity||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  document.getElementById('disp_maxbet').innerText=(m.maxBet||0).toLocaleString();
  document.getElementById('disp_hands').innerText=(state.history.length||0).toLocaleString();
  document.getElementById('disp_mode').innerText=document.getElementById('net_mode').value;
  document.getElementById('disp_strength').innerText=(m.lastNet.strength||0).toFixed(2);

  document.getElementById('comm_turnover').innerText = (m.commTurnover||0).toLocaleString(undefined,{maximumFractionDigits:2});
  document.getElementById('comm_total').innerText = commCycle.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  document.getElementById('comm_hands').innerText = (m.commHands||0).toLocaleString();
  document.getElementById('comm_net_plus').innerText = eqCycle.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});

  const left=modeBankrollLeft(m);
  const el=document.getElementById('bankroll_left_disp');
  el.innerText = left.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  el.style.color = left>=getMinBet() ? '#d7f7e6' : '#ffb3b3';

  document.getElementById('cycle_no_disp').innerText = `${cycleNoByMode.legacy} / ${cycleNoByMode.kcapA} / ${cycleNoByMode.kcapB}`;

  document.getElementById('sim_round_count').innerText=simRoundCount;
  document.getElementById('sim_success_count').innerText=simSuccessCount;
  document.getElementById('sim_round_count_bot').innerText=simRoundCount;
  document.getElementById('sim_success_count_bot').innerText=simSuccessCount;

  document.getElementById('mon_bal').innerText = Math.round(m.staker.bal||0).toLocaleString();
  document.getElementById('mon_info').innerText = `Wait:${m.staker.wait} | Stg:${m.staker.stage} | CL:${m.staker.cons_loss}`;
  document.getElementById('mon_net').innerText = m.lastNet.side;
  document.getElementById('mon_net_info').innerText = `P:${m.lastNet.p.toFixed(2)} B:${m.lastNet.b.toFixed(2)} (${document.getElementById('net_mode').value})`;

  function fmtRec(side){ return (side==='P')?'PLAYER':(side==='B')?'BANKER':'WAIT'; }
  function lineMode(modeKey){
    const mm = modes[modeKey];
    const cpM = modeCycleProfit(mm);
    const commM = (mm.commTotal||0) - (mm.commTotalStart||0);
    const eqM = cpM + commM;
    return `${eqM.toFixed(2)} | DD ${(mm.maxDDEquity||0).toFixed(2)} | MaxBet ${(mm.maxBet||0).toFixed(0)}`;
  }
  document.getElementById('mm_legacy_line').innerText = lineMode(MODES.LEGACY);
  document.getElementById('mm_kcapA_line').innerText = lineMode(MODES.KCAP_A);
  document.getElementById('mm_kcapB_line').innerText = lineMode(MODES.KCAP_B);

  const sL = (signalSource()==='shared') ? computeSignalShared() : computeSignalForMode(MODES.LEGACY);
  const sA = (signalSource()==='shared') ? computeSignalShared() : computeSignalForMode(MODES.KCAP_A);
  const sB = (signalSource()==='shared') ? computeSignalShared() : computeSignalForMode(MODES.KCAP_B);
  const rL = computeRecForMode(MODES.LEGACY, sL);
  const rA = computeRecForMode(MODES.KCAP_A, sA);
  const rB = computeRecForMode(MODES.KCAP_B, sB);
  document.getElementById('mm_legacy_rec').innerText = `${fmtRec(rL.side)} ${(rL.bet||0).toLocaleString()}`;
  document.getElementById('mm_kcapA_rec').innerText = `${fmtRec(rA.side)} ${(rA.bet||0).toLocaleString()}`;
  document.getElementById('mm_kcapB_rec').innerText = `${fmtRec(rB.side)} ${(rB.bet||0).toLocaleString()}`;

  highlightCompareCards();
  renderBigRoad();
  renderSessionHistoryAll();
  updateLifetimeUI();
  updateChart();
  refreshShoeUI();
}

function syncSimSettings(source){
  if(source==='top'){
    document.getElementById('sim_hands_bot').value=document.getElementById('sim_hands').value;
    document.getElementById('sim_speed_bot').value=document.getElementById('sim_speed').value;
    document.getElementById('rng_method_bot').value=document.getElementById('rng_method').value;
  }else{
    document.getElementById('sim_hands').value=document.getElementById('sim_hands_bot').value;
    document.getElementById('sim_speed').value=document.getElementById('sim_speed_bot').value;
    document.getElementById('rng_method').value=document.getElementById('rng_method_bot').value;
  }
  onRngChange();
}
function generateOutcome(){
  const method=document.getElementById('rng_method').value;
  if(method==='crypto'){
    const array=new Uint32Array(1);
    window.crypto.getRandomValues(array);
    const val=array[0]/(0xFFFFFFFF+1);
    return val<0.4932?'P':'B';
  }
  if(method==='shoe') return dealBaccarat();
  return Math.random()<0.4932?'P':'B';
}

function restoreRecommended(){
  document.getElementById('min_bet').value = FIXED.MIN_BET;
  document.getElementById('chip_size').value = FIXED.CHIP_SIZE;
  document.getElementById('commission_rate').value = FIXED.REBATE_RATE;
  document.getElementById('rng_method').value=FIXED.RNG_METHOD;
  document.getElementById('rng_method_bot').value=FIXED.RNG_METHOD;
  document.getElementById('shoe_pen').value=String(FIXED.SHOE_PEN);
  document.getElementById('max_wait_hands').value=String(FIXED.MAX_WAIT_HANDS);
  document.getElementById('init_bank').value = 1000000.0;
  document.getElementById('max_bet_cap').value = 250000.0;
  document.getElementById('min_strength').value = 4.03;
  document.getElementById('net_mode').value = 'weight';
  document.getElementById('reset_road_on_cycle').value = 'yes';
  document.getElementById('enable_survival').checked = false;
  document.getElementById('surv_div').value = 6.11;
  document.getElementById('surv_trigger').value = 99.0;
  document.getElementById('use_anti_last').checked = true;
  document.getElementById('use_follow_last').checked = true;
  document.getElementById('use_offset').checked = true;
  document.getElementById('use_policy_ai').checked = true;
  document.getElementById('use_something_else').checked = true;
  document.getElementById('w_anti_last').value = 0.96;
  document.getElementById('w_follow_last').value = 3.71;
  document.getElementById('w_offset').value = 3.86;
  document.getElementById('w_policy_ai').value = 3.99;
  document.getElementById('w_something_else').value = 2.10;
  document.getElementById('require_both_x').checked = true;
  document.getElementById('x_live_hands_on_trigger').value = 11;
  document.getElementById('x_mult_fail').value = 0.10;
  document.getElementById('x_mult_pass').value = 1.24;
  document.getElementById('x_rule_mode').value = 'D_stop';
  document.getElementById('x_times_target').value = 2;
  document.getElementById('x_count_source').value = 'include_virtual';
  document.getElementById('x_reset_after_trigger').value = 'none';
  document.getElementById('x_stop_on_pass').checked = true;
  document.getElementById('target_profit').value = 1000;
  document.getElementById('use_dynamic_target').checked = true;
  document.getElementById('target_pct').value = 1;
  document.getElementById('signal_source').value = 'per_mode';
  document.getElementById('kelly_p_source').value = 'logistic';
  document.getElementById('display_mode').value = 'kcapA';
  document.getElementById('p_fixed_p').value = 0.510;
  document.getElementById('p_fixed_b').value = 0.500;
  document.getElementById('p_cap').value = 0.540;
  document.getElementById('p_log_k').value = 0.35;
  document.getElementById('edge_max').value = 0.040;
  document.getElementById('kelly_scale').value = 0.50;
  document.getElementById('kcap_max_pct').value = 0.50;
  document.getElementById('first_loss_tier').value = 'low';

  enabledModes = { legacy:true, kcapA:true, kcapB:true };
  updateModeButtonsUI();
  syncSimSettings('top');
  onRngChange();
  updateUI();
  autosaveNow('restore-default');
}

function resetAll(){
  if(confirm("‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?")){
    try{ clearAutosave(); }catch(e){}
    location.reload();
  }
}
function showGuideModal(){ document.getElementById('guideModal').style.display='flex'; }
function closeGuideModal(){ document.getElementById('guideModal').style.display='none'; }

function runSimulation(){
  const n=parseInt(document.getElementById('sim_hands').value)||1;
  saveState();
  for(let i=0;i<n;i++) processResultAll(generateOutcome(), true);
  updateUI();
  autosaveNow('simulate');
}

function toggleAutoSim(){
  if(isAutoRunning) return;
  isAutoRunning=true;
  document.getElementById('btn_auto_sim').style.display='none';
  document.getElementById('btn_auto_sim_bot').style.display='none';
  document.getElementById('btn_stop_sim').style.display='inline-block';
  document.getElementById('btn_stop_sim_bot').style.display='inline-block';
  document.getElementById('sim_stats_display').style.display='block';
  document.getElementById('sim_stats_display_bot').style.display='block';
  if(simRoundCount===0){ simRoundCount=1; simSuccessCount=0; }
  const speed=parseInt(document.getElementById('sim_speed').value);
  if(speed===0) runInstantLoop();
  else autoPlayStep();
}
function stopAutoSim(){
  isAutoRunning=false;
  if(autoTimer) clearTimeout(autoTimer);
  document.getElementById('btn_auto_sim').style.display='inline-block';
  document.getElementById('btn_auto_sim_bot').style.display='inline-block';
  document.getElementById('btn_stop_sim').style.display='none';
  document.getElementById('btn_stop_sim_bot').style.display='none';
  autosaveNow('stop-auto');
}
async function runInstantLoop(){
  while(isAutoRunning){
    processResultAll(generateOutcome(), true);
    await new Promise(r=>setTimeout(r,0));
  }
}
function autoPlayStep(){
  if(!isAutoRunning) return;
  const speed=parseInt(document.getElementById('sim_speed').value);
  processResultAll(generateOutcome(), true);
  simRoundCount += 1;
  updateUI();
  autoTimer=setTimeout(autoPlayStep, speed);
}

/* =========================
   AUTOSAVE / RESTORE
   ========================= */
const AUTOSAVE_KEY = 'baccarat_ai_v36_autosave_v3_3modes_kcapAB';
const AUTOSAVE_INTERVAL_MS = 60 * 1000;
let autosaveTimer = null;
let autosaveEnabled = true;

function captureUISettings(){
  const ids = [
    'rng_method','rng_method_bot','sim_hands','sim_hands_bot','sim_speed','sim_speed_bot','shoe_pen',
    'net_mode','min_strength','reset_road_on_cycle',
    'use_offset','w_offset','use_anti_last','w_anti_last','use_follow_last','w_follow_last','use_something_else','w_something_else','use_policy_ai','w_policy_ai',
    'require_both_x','x_live_hands_on_trigger','max_wait_hands','x_mult_pass','x_mult_fail','x_rule_mode','x_times_target','x_count_source','x_reset_after_trigger','x_stop_on_pass',
    'commission_rate','init_bank','max_bet_cap','min_bet','chip_size',
    'use_dynamic_target','target_pct','target_profit',
    'signal_source','display_mode',
    'kelly_p_source',
    'p_fixed_p','p_fixed_b','p_cap','p_log_k','edge_max',
    'kelly_scale','kcap_max_pct',
    'enable_survival','surv_trigger','surv_div',
    'first_loss_tier'
  ];
  const settings = {};
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    if(el.type === 'checkbox') settings[id] = !!el.checked;
    else settings[id] = el.value;
  });
  // persist enabledModes
  settings._enabledModes = JSON.stringify(enabledModes);
  return settings;
}
function applyUISettings(settings){
  if(!settings) return;
  Object.keys(settings).forEach(id=>{
    if(id === '_enabledModes') return;
    const el = document.getElementById(id);
    if(!el) return;
    if(el.type === 'checkbox') el.checked = !!settings[id];
    else el.value = settings[id];
  });
  if(settings._enabledModes){
    try{
      const em = JSON.parse(settings._enabledModes);
      if(em && typeof em === 'object') enabledModes = em;
    }catch(e){}
  }
  try{ syncSimSettings('top'); }catch(e){}
  try{ onRngChange(); }catch(e){}
}
function buildAutosavePayload(){
  return {
    v: 3,
    ts: Date.now(),
    state, shoe, modes, lifetimeModes, modeGraph, enabledModes,
    cycleHistoryByMode, cycleNoByMode, cycleStartTsByMode,
    simRoundCount, simSuccessCount,
    ui: captureUISettings()
  };
}
function applyAutosavePayload(p){
  if(!p) return false;
  applyUISettings(p.ui);
  if(p.state) state = p.state;
  if(p.shoe) shoe = p.shoe;
  if(p.modes) modes = p.modes;
  if(p.lifetimeModes) lifetimeModes = p.lifetimeModes;
  if(p.modeGraph) modeGraph = p.modeGraph;
  if(p.enabledModes) enabledModes = p.enabledModes;
  if(p.cycleHistoryByMode) cycleHistoryByMode = p.cycleHistoryByMode;
  if(p.cycleNoByMode) cycleNoByMode = p.cycleNoByMode;
  if(p.cycleStartTsByMode) cycleStartTsByMode = p.cycleStartTsByMode;
  simRoundCount = Number(p.simRoundCount || 0);
  simSuccessCount = Number(p.simSuccessCount || 0);
  try{ updateModeButtonsUI(); }catch(e){}
  try{ updateUI(); }catch(e){}
  return true;
}
function autosaveNow(reason='interval'){
  if(!autosaveEnabled) return;
  try{
    const payload = buildAutosavePayload();
    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
  }catch(err){
    console.warn('AUTOSAVE failed:', err);
  }
}
function loadAutosave(){
  try{
    const raw = localStorage.getItem(AUTOSAVE_KEY);
    if(!raw) return null;
    const p = JSON.parse(raw);
    if(!p || !p.v) return null;
    return p;
  }catch(e){
    console.warn('LOAD autosave failed:', e);
    return null;
  }
}
function clearAutosave(){
  try{ localStorage.removeItem(AUTOSAVE_KEY); }catch(e){}
}
function startAutosaveTimer(){
  if(autosaveTimer) clearInterval(autosaveTimer);
  autosaveTimer = setInterval(()=>autosaveNow('interval'), AUTOSAVE_INTERVAL_MS);
}
window.addEventListener('beforeunload', ()=>autosaveNow('beforeunload'));
document.addEventListener('visibilitychange', ()=>{
  if(document.visibilityState === 'hidden') autosaveNow('hidden');
});

window.onload=function(){
  modes[MODES.LEGACY] = freshModeState();
  modes[MODES.KCAP_A] = freshModeState();
  modes[MODES.KCAP_B] = freshModeState();
  for(const k of [MODES.LEGACY, MODES.KCAP_A, MODES.KCAP_B]){
    modes[k].cycleStartBalance = modes[k].realBalance;
    modes[k].commTotalStart = modes[k].commTotal;
  }
  lifetimeModes[MODES.LEGACY]=freshLifetime();
  lifetimeModes[MODES.KCAP_A]=freshLifetime();
  lifetimeModes[MODES.KCAP_B]=freshLifetime();
  modeGraph[MODES.LEGACY] = { labels:[0], data:[0] };
  modeGraph[MODES.KCAP_A] = { labels:[0], data:[0] };
  modeGraph[MODES.KCAP_B] = { labels:[0], data:[0] };

  const snap = loadAutosave();
  if(snap && snap.ts){
    const when = new Date(snap.ts).toLocaleString('th-TH', {hour12:false});
    const ok = confirm(`‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (${when})\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`);
    if(ok){
      applyAutosavePayload(snap);
    }else{
      clearAutosave();
      restoreRecommended();
      renderSessionHistoryAll();
      updateUI();
    }
  }else{
    restoreRecommended();
    renderSessionHistoryAll();
    updateUI();
  }

  startAutosaveTimer();
  autosaveNow('startup');
};
</script>
</body>
</html>
