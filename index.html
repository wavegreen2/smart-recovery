<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat Recovery Simulator</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f4f7f6; padding: 20px; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .input-group { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .input-item { display: flex; flex-direction: column; }
        label { font-weight: bold; margin-bottom: 5px; font-size: 0.9em; }
        input, select, textarea { padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { background: #3498db; color: white; border: none; padding: 12px; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold; }
        button:hover { background: #2980b9; }
        #log-area { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 4px; height: 400px; overflow-y: auto; font-family: 'Courier New', Courier, monospace; font-size: 13px; margin-top: 20px; white-space: pre-wrap; }
        .summary { background: #e8f4fd; padding: 15px; border-radius: 4px; margin-top: 20px; display: none; }
    </style>
</head>
<body>

<div class="container">
    <h2>üìä Baccarat Recovery Simulator</h2>
    
    <div class="input-group">
        <div class="input-item">
            <label>Mode</label>
            <select id="mode">
                <option value="r">Random Simulation</option>
                <option value="a">Auto Data (from text below)</option>
            </select>
        </div>
        <div class="input-item">
            <label>Side Preference</label>
            <select id="side_preference">
                <option value="PLAYER">PLAYER</option>
                <option value="BANKER">BANKER</option>
            </select>
        </div>
        <div class="input-item">
            <label>Unit Size</label>
            <input type="number" id="unit_size" value="10">
        </div>
        <div class="input-item">
            <label>Virtual Loss Trigger (Wait)</label>
            <input type="number" id="virtual_loss_trigger" value="2">
        </div>
        <div class="input-item">
            <label>Total Rounds (Random Mode)</label>
            <input type="number" id="total_rounds" value="1000">
        </div>
        <div class="input-item">
            <label>Rebate Rate (%)</label>
            <input type="number" id="rebate_rate" step="0.01" value="1.0">
        </div>
    </div>

    <div class="input-item" style="margin-bottom: 15px;">
        <label>Raw Data (CSV format: Index,Result,Result...)</label>
        <textarea id="raw_data" rows="3">1,B,T,P,B,B,B,P,P,P,T,P,P,P,P,T,B,P,P,B,P,P,B,B,P,P,B,P,B,P,T,B,T,B,P,P,T,B,P,P,B,P,P,T,P,P,P,P,P,B,P,B,B,P,B,B,P,B,B,P,B,B,B,B,P,B,P,B,P,T,P,B,B,B,P,B,B,P,P,P</textarea>
    </div>

    <button onclick="startSimulation()">üöÄ Start Simulation</button>

    <div id="summary" class="summary"></div>
    <div id="log-area">Log system ready... (Results will appear here)</div>
</div>

<script>
    // --- Logic Functions ---
    const getFibo = (n) => {
        if (n <= 0) return 1;
        if (n === 1) return 1;
        let a = 1, b = 1;
        for (let i = 2; i <= n; i++) {
            [a, b] = [b, a + b];
        }
        return b;
    };

    function logToScreen(msg) {
        const logArea = document.getElementById('log-area');
        logArea.innerText += msg + "\n";
        logArea.scrollTop = logArea.scrollHeight;
    }

    async function runSingleSession(config) {
        let { mode, resultList, startIdx, targetProfit, unitSize, initialBankroll, rebateRate, sidePreference, stopLossThreshold, martyMult, fiboMult } = config;

        let bankroll = initialBankroll;
        let peakBankroll = initialBankroll;
        let maxBetEncountered = 0;
        let maxDrawdown = 0;
        
        let state = "FLAT";
        let martyStep = 0;
        let fiboIdx = 0;
        let martyStepsLimit = 12;
        let hasLostSincePeak = false;
        let currentIdx = startIdx;

        while (true) {
            let currentDrawdown = peakBankroll - bankroll;
            if (currentDrawdown >= stopLossThreshold) {
                state = "FLAT"; martyStep = 0; fiboIdx = 0;
            }

            let rawBet = unitSize;
            if (state === "FLAT") {
                if (currentDrawdown > 0 && hasLostSincePeak) {
                    rawBet = Math.max(Math.ceil(currentDrawdown / 4), unitSize);
                }
            } else if (state === "MARTY") {
                rawBet = unitSize * Math.pow(martyMult, martyStep);
            } else if (state === "FIBO") {
                rawBet = getFibo(fiboIdx) * fiboMult;
            }

            let neededToRecover = currentDrawdown + unitSize;
            let bet = (state !== "FLAT") ? Math.min(rawBet, neededToRecover) : rawBet;

            let isMaxBetActive = false;
            if (bet >= stopLossThreshold) {
                bet = stopLossThreshold;
                isMaxBetActive = true;
            }

            let currentProfit = bankroll - initialBankroll;
            let remainingToTarget = targetProfit - currentProfit;
            if (bet > remainingToTarget && remainingToTarget > 0) {
                bet = Math.max(unitSize, remainingToTarget);
            }

            if (bet > maxBetEncountered) maxBetEncountered = bet;

            // Get Result
            let actualResult = null;
            if (mode === 'a') {
                if (currentIdx < resultList.length) {
                    actualResult = resultList[currentIdx];
                    currentIdx++;
                } else {
                    return { status: "OUT_OF_DATA", profit: (bankroll - initialBankroll), mdd: maxDrawdown, m_bet: maxBetEncountered, nextIdx: currentIdx };
                }
            } else {
                if (currentIdx >= config.totalRoundsLimit) {
                    return { status: "OUT_OF_DATA", profit: (bankroll - initialBankroll), mdd: maxDrawdown, m_bet: maxBetEncountered, nextIdx: currentIdx };
                }
                actualResult = Math.random() * 100 <= 50.68 ? "B" : "P";
                currentIdx++;
            }

            if (actualResult === "T") continue;

            let isWin = (actualResult === "P" && sidePreference === "PLAYER") || (actualResult === "B" && sidePreference === "BANKER");
            let payout = (sidePreference === "BANKER") ? 0.95 : 1.0;
            
            bankroll += (bet * rebateRate);

            if (isWin) {
                bankroll += (bet * payout);
                logToScreen(`   [Hand ${currentIdx}] Bet: ${bet.toLocaleString()} (${actualResult}) | ‚úÖ WIN | BR: ${bankroll.toLocaleString()}`);
                if (state === "FIBO") {
                    fiboIdx = Math.max(-1, fiboIdx - 2);
                    if (fiboIdx < 0) { state = "FLAT"; fiboIdx = 0; }
                } else {
                    if (bankroll >= peakBankroll) hasLostSincePeak = false;
                    state = "FLAT"; martyStep = 0;
                }
            } else {
                bankroll -= bet;
                hasLostSincePeak = true;
                logToScreen(`   [Hand ${currentIdx}] Bet: ${bet.toLocaleString()} (${actualResult}) | ‚ùå LOSS | BR: ${bankroll.toLocaleString()}`);
                if (isMaxBetActive) {
                    state = "FLAT"; martyStep = 0; fiboIdx = 0;
                } else {
                    if (state === "FLAT") { state = "MARTY"; martyStep = 1; }
                    else if (state === "MARTY") {
                        martyStep++;
                        if (martyStep > martyStepsLimit) { state = "FIBO"; fiboIdx = 0; }
                    } else if (state === "FIBO") {
                        fiboIdx++;
                    }
                }
            }

            if (bankroll > peakBankroll) peakBankroll = bankroll;
            let ddown = peakBankroll - bankroll;
            if (ddown > maxDrawdown) maxDrawdown = ddown;

            if (bankroll <= 0) return { status: "BUST", profit: (bankroll - initialBankroll), mdd: maxDrawdown, m_bet: maxBetEncountered, nextIdx: currentIdx };
            if ((bankroll - initialBankroll) >= targetProfit) return { status: "WIN", profit: (bankroll - initialBankroll), mdd: maxDrawdown, m_bet: maxBetEncountered, nextIdx: currentIdx };
        }
    }

    async function startSimulation() {
        // UI Reset
        document.getElementById('log-area').innerText = "";
        const summaryDiv = document.getElementById('summary');
        summaryDiv.style.display = "none";

        // Get Inputs
        const mode = document.getElementById('mode').value;
        const rawData = document.getElementById('raw_data').value;
        const sidePreference = document.getElementById('side_preference').value;
        const unitSize = parseFloat(document.getElementById('unit_size').value);
        const virtualLossTrigger = parseInt(document.getElementById('virtual_loss_trigger').value);
        const totalRoundsInput = parseInt(document.getElementById('total_rounds').value);
        const rebateRate = parseFloat(document.getElementById('rebate_rate').value) / 100;

        let fullResults = [];
        if (mode === 'a') {
            rawData.trim().split('\n').forEach(line => {
                const parts = line.split(',');
                fullResults.push(...parts.slice(1).map(x => x.trim()));
            });
        }

        let baseTarget = 0.01;
        let baseBankroll = 20.0;
        let totalLossAccumulated = 0;
        let currentTarget = baseTarget;
        let currentBankroll = baseBankroll;
        
        let overallMaxBet = 0, overallMaxDrawdown = 0, maxConsecutiveBusts = 0, currentConsecutiveBusts = 0;
        let consecutiveVirtualLosses = 0, totalRealSessions = 0, currentDataIdx = 0;

        while (true) {
            if (mode === 'r' && currentDataIdx >= totalRoundsInput) break;
            if (totalRealSessions >= 1000) break; // Safety limit

            let isVirtual = consecutiveVirtualLosses < virtualLossTrigger;

            if (isVirtual) {
                logToScreen(`\n--- üß™ VIRTUAL SESSION (Wait: ${consecutiveVirtualLosses}/${virtualLossTrigger}) ---`);
            } else {
                logToScreen(`\n--- üí∞ REAL SESSION ${totalRealSessions + 1} (START) ---`);
            }

            let result = await runSingleSession({
                mode,
                resultList: fullResults,
                startIdx: currentDataIdx,
                targetProfit: currentTarget,
                initialBankroll: currentBankroll,
                unitSize,
                martyMult: 2,
                fiboMult: 10,
                rebateRate,
                sidePreference,
                stopLossThreshold: 5000,
                totalRoundsLimit: totalRoundsInput
            });

            currentDataIdx = result.nextIdx;

            if (isVirtual) {
                if (result.status === "BUST") {
                    consecutiveVirtualLosses++;
                    logToScreen(`üìâ Virtual Result: BUST (${consecutiveVirtualLosses}/${virtualLossTrigger})`);
                } else if (result.status === "WIN") {
                    consecutiveVirtualLosses = 0;
                    logToScreen(`üîÑ Virtual Result: WIN (Resetting)`);
                } else if (result.status === "OUT_OF_DATA") break;
                continue;
            }

            // Real Session Logic
            totalRealSessions++;
            if (result.m_bet > overallMaxBet) overallMaxBet = result.m_bet;
            if (result.mdd > overallMaxDrawdown) overallMaxDrawdown = result.mdd;

            if (result.status === "WIN") {
                logToScreen(`‚úÖ REAL WIN: Profit +${result.profit.toFixed(2)}`);
                totalLossAccumulated = 0;
                currentTarget = baseTarget;
                currentBankroll = baseBankroll;
                currentConsecutiveBusts = 0;
                consecutiveVirtualLosses = 0;
            } else {
                logToScreen(`‚ùå REAL ${result.status}: Loss ${result.profit.toFixed(2)}`);
                totalLossAccumulated += Math.abs(result.profit);
                currentTarget = totalLossAccumulated + baseTarget;
                currentBankroll = currentTarget * 1.5;
                currentConsecutiveBusts++;
                if (currentConsecutiveBusts > maxConsecutiveBusts) maxConsecutiveBusts = currentConsecutiveBusts;
                logToScreen(`‚ö†Ô∏è RECOVERY | Accumulated Loss: ${totalLossAccumulated.toFixed(2)}`);
            }

            if (result.status === "OUT_OF_DATA") break;
        }

        // Final Summary
        summaryDiv.style.display = "block";
        summaryDiv.innerHTML = `
            <h3>üìä Summary Report</h3>
            <p>üéØ Total Real Sessions: <b>${totalRealSessions}</b></p>
            <p>üî• Max Consecutive Busts: <b>${maxConsecutiveBusts}</b></p>
            <p>üí∏ Overall Max Bet: <b>${overallMaxBet.toLocaleString()}</b></p>
            <p>üìâ Overall Max Drawdown: <b>${overallMaxDrawdown.toLocaleString()}</b></p>
        `;
    }
</script>

</body>
</html>
