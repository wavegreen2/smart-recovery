<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat Strategy Simulator</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f4f7f6; margin: 20px; }
        .container { max-width: 900px; margin: auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h2 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .section { padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
        label { display: block; margin-top: 10px; font-weight: bold; font-size: 0.9em; }
        input, select, textarea { width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .controls { margin-top: 20px; display: flex; gap: 10px; }
        button { flex: 1; padding: 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: 0.3s; }
        .btn-start { background: #27ae60; color: white; }
        .btn-manual { background: #3498db; color: white; display: none; }
        .btn-clear { background: #e74c3c; color: white; }
        #log { height: 300px; overflow-y: scroll; background: #1e1e1e; color: #adadad; padding: 10px; font-family: monospace; border-radius: 6px; margin-top: 20px; font-size: 13px; }
        .summary { margin-top: 20px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center; }
        .stat-box { background: #ecf0f1; padding: 10px; border-radius: 8px; }
        .stat-val { display: block; font-size: 1.2em; font-weight: bold; color: #2980b9; }
        .win { color: #2ecc71; font-weight: bold; }
        .loss { color: #e74c3c; font-weight: bold; }
        .virtual { color: #f39c12; font-style: italic; }
    </style>
</head>
<body>

<div class="container">
    <h2>üé∞ Baccarat Recovery Simulator</h2>
    
    <div class="grid">
        <div class="section">
            <label>Mode</label>
            <select id="mode" onchange="toggleModeInput()">
                <option value="a">Auto Data</option>
                <option value="m">Manual Input (Hand by Hand)</option>
                <option value="r">Random Simulation</option>
            </select>

            <label>Side Preference</label>
            <select id="side_preference">
                <option value="PLAYER">PLAYER</option>
                <option value="BANKER">BANKER</option>
            </select>

            <label>Unit Size</label>
            <input type="number" id="unit_size" value="10">
        </div>

        <div class="section">
            <label>Virtual Loss Trigger (‡∏£‡∏≠‡πÅ‡∏ï‡∏Å‡∏Å‡∏µ‡πà‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≠‡∏¢‡πÅ‡∏ó‡∏á‡∏à‡∏£‡∏¥‡∏á)</label>
            <input type="number" id="virtual_loss_trigger" value="2">
            
            <label>Stop Loss Threshold (‡∏ï‡πà‡∏≠‡∏ï‡∏≤)</label>
            <input type="number" id="stop_loss_threshold" value="10000000000">

            <label>Marty Multiplier</label>
            <input type="number" id="marty_mult" value="2">
        </div>
    </div>

    <div class="section" id="auto_data_section" style="margin-top:20px;">
        <label>Raw Data (CSV Format)</label>
        <textarea id="raw_data" rows="3">1,B,T,P,B,B,B,P,P,P,T,P,P,P,P,T,B,P,P,B,P,P,B,B,P,P,B,P,B,P,T,B,T,B,P,P,T,B,P,P,B,P,P,T,P,P,P,P,P,B,P,B,B,P,B,B,P,B,B,P,B,B,B,B,P,B,P,B,P,T,P,B,B,B,P,B,B,P,P,P</textarea>
    </div>

    <div class="summary">
        <div class="stat-box">Profit<span id="stat_profit" class="stat-val">0.00</span></div>
        <div class="stat-box">Max Bet<span id="stat_max_bet" class="stat-val">0.00</span></div>
        <div class="stat-box">Max Drawdown<span id="stat_mdd" class="stat-val">0.00</span></div>
        <div class="stat-box">Busts<span id="stat_busts" class="stat-val">0</span></div>
    </div>

    <div class="controls">
        <button id="btn_start" class="btn-start" onclick="startSimulation()">Start Simulation</button>
        <button id="btn_p" class="btn-manual" onclick="submitManual('P')">P</button>
        <button id="btn_b" class="btn-manual" onclick="submitManual('B')">B</button>
        <button id="btn_t" class="btn-manual" onclick="submitManual('T')">T</button>
        <button class="btn-clear" onclick="resetAll()">Reset</button>
    </div>

    <div id="log"></div>
</div>

<script>
    // --- Global Variables (State Management) ---
    let simState = {
        mode: 'a',
        fullResults: [],
        currentIdx: 0,
        baseTarget: 0.01,
        baseBankroll: 20.0,
        totalLossAccumulated: 0,
        currentTarget: 0.01,
        currentBankroll: 20.0,
        totalRealSessions: 0,
        consecutiveVirtualLosses: 0,
        maxConsecutiveBusts: 0,
        currentConsecutiveBusts: 0,
        overallMaxBet: 0,
        overallMaxDrawdown: 0,
        totalProfit: 0,
        isManualWaiting: false,
        manualResolve: null,
        currentSession: null
    };

    function toggleModeInput() {
        const mode = document.getElementById('mode').value;
        document.getElementById('auto_data_section').style.display = (mode === 'a') ? 'block' : 'none';
        document.getElementById('btn_start').style.display = (mode === 'm') ? 'none' : 'block';
        
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Manual Mode
        if (mode === 'm') {
            startSimulation(); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏•‡∏π‡∏õ‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        }
    }

    function log(msg, type = '') {
        const div = document.getElementById('log');
        const span = document.createElement('div');
        if (type) span.className = type;
        span.innerHTML = msg;
        div.appendChild(span);
        div.scrollTop = div.scrollHeight;
    }

    function getFibo(n) {
        if (n <= 0) return 1;
        if (n === 1) return 1;
        let a = 1, b = 1;
        for (let i = 2; i <= n; i++) {
            let temp = a + b;
            a = b;
            b = temp;
        }
        return b;
    }

    async function getNextResult() {
        const mode = document.getElementById('mode').value;
        if (mode === 'a') {
            if (simState.currentIdx < simState.fullResults.length) {
                return simState.fullResults[simState.currentIdx++];
            }
            return null;
        } else if (mode === 'r') {
            if (simState.currentIdx >= 10000000) return null;
            simState.currentIdx++;
            return Math.random() * 100 <= 50.68 ? 'B' : 'P';
        } else if (mode === 'm') {
            // ‡πÇ‡∏´‡∏°‡∏î Manual: ‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°
            document.querySelectorAll('.btn-manual').forEach(b => b.style.display = 'inline-block');
            log("Waiting for Manual Input (P/B/T)...");
            const res = await new Promise(resolve => { simState.manualResolve = resolve; });
            document.querySelectorAll('.btn-manual').forEach(b => b.style.display = 'none');
            return res;
        }
        return null;
    }

    function submitManual(val) {
        if (simState.manualResolve) simState.manualResolve(val);
    }

    async function runSingleSession(isVirtual) {
        let bankroll = simState.currentBankroll;
        let initialBankroll = bankroll;
        let peakBankroll = bankroll;
        let maxBetEncencountered = 0;
        let maxDrawdown = 0;
        
        let state = "FLAT";
        let martyStep = 0;
        let fiboIdx = 0;
        let hasLostSincePeak = false;

        const config = {
            unitSize: parseFloat(document.getElementById('unit_size').value),
            martyMult: parseFloat(document.getElementById('marty_mult').value),
            fiboMult: 10000000000000000, // ‡∏ï‡∏≤‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
            targetProfit: simState.currentTarget,
            side: document.getElementById('side_preference').value,
            stopLoss: parseFloat(document.getElementById('stop_loss_threshold').value),
            rebateRate: 0.01
        };

        while (true) {
            let currentDrawdown = peakBankroll - bankroll;
            if (currentDrawdown >= config.stopLoss) {
                state = "FLAT"; martyStep = 0; fiboIdx = 0;
            }

            let rawBet = 0;
            if (state === "FLAT") {
                rawBet = (currentDrawdown > 0 && hasLostSincePeak) ? Math.max(Math.ceil(currentDrawdown / 4), config.unitSize) : config.unitSize;
            } else if (state === "MARTY") {
                rawBet = config.unitSize * Math.pow(config.martyMult, martyStep);
            } else if (state === "FIBO") {
                rawBet = getFibo(fiboIdx) * config.fiboMult;
            }

            let neededToRecover = currentDrawdown + config.unitSize;
            let bet = (state !== "FLAT") ? Math.min(rawBet, neededToRecover) : rawBet;

            let isMaxBetActive = false;
            if (bet >= config.stopLoss) {
                bet = config.stopLoss;
                isMaxBetActive = true;
            }

            let remainingToTarget = config.targetProfit - (bankroll - initialBankroll);
            if (bet > remainingToTarget && remainingToTarget > 0) {
                bet = Math.max(config.unitSize, remainingToTarget);
            }

            if (bet > maxBetEncencountered) maxBetEncencountered = bet;

            const actualResult = await getNextResult();
            if (!actualResult) return { status: "OUT_OF_DATA", profit: bankroll - initialBankroll, mdd: maxDrawdown, m_bet: maxBetEncencountered };

            if (actualResult === 'T') {
                log(`   [Hand ${simState.currentIdx}] TIE - Skip`);
                continue;
            }

            const isWin = (actualResult === config.side);
            const payout = (config.side === "BANKER") ? 0.95 : 1.0;
            bankroll += (bet * config.rebateRate);

            if (isWin) {
                bankroll += (bet * payout);
                log(`   [Hand ${simState.currentIdx}] Bet: ${bet.toLocaleString()} (${actualResult}) | <span class="win">‚úÖ WIN</span> | BR: ${bankroll.toLocaleString()}`, isVirtual ? 'virtual' : '');
                if (state === "FIBO") {
                    fiboIdx = Math.max(-1, fiboIdx - 2);
                    if (fiboIdx < 0) { state = "FLAT"; fiboIdx = 0; }
                } else {
                    if (bankroll >= peakBankroll) hasLostSincePeak = false;
                    state = "FLAT"; martyStep = 0;
                }
            } else {
                bankroll -= bet;
                hasLostSincePeak = true;
                log(`   [Hand ${simState.currentIdx}] Bet: ${bet.toLocaleString()} (${actualResult}) | <span class="loss">‚ùå LOSS</span> | BR: ${bankroll.toLocaleString()}`, isVirtual ? 'virtual' : '');
                if (isMaxBetActive) {
                    state = "FLAT"; martyStep = 0; fiboIdx = 0;
                } else {
                    if (state === "FLAT") { state = "MARTY"; martyStep = 1; }
                    else if (state === "MARTY") {
                        martyStep++;
                        if (martyStep > 12) { state = "FIBO"; fiboIdx = 0; }
                    }
                    else if (state === "FIBO") { fiboIdx++; }
                }
            }

            if (bankroll > peakBankroll) peakBankroll = bankroll;
            let d = peakBankroll - bankroll;
            if (d > maxDrawdown) maxDrawdown = d;

            if (bankroll <= 0) return { status: "BUST", profit: bankroll - initialBankroll, mdd: maxDrawdown, m_bet: maxBetEncencountered };
            if ((bankroll - initialBankroll) >= config.targetProfit) return { status: "WIN", profit: bankroll - initialBankroll, mdd: maxDrawdown, m_bet: maxBetEncencountered };
        }
    }

    async function startSimulation() {
        const mode = document.getElementById('mode').value;
        const vLimit = parseInt(document.getElementById('virtual_loss_trigger').value);
        
        if (mode === 'a') {
            const raw = document.getElementById('raw_data').value;
            simState.fullResults = raw.split('\n').flatMap(line => line.split(',').slice(1).map(s => s.trim()));
        }

        log("--- Starting Simulation ---");
        
        while (true) {
            // ‡∏´‡∏¢‡∏∏‡∏î‡∏ñ‡πâ‡∏≤‡πÇ‡∏´‡∏°‡∏î Random ‡∏Ñ‡∏£‡∏ö 10 session ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏°‡∏î
            if (mode === 'r' && simState.totalRealSessions >= 10) break;
            if (mode === 'a' && simState.currentIdx >= simState.fullResults.length) break;

            let isVirtual = simState.consecutiveVirtualLosses < vLimit;
            
            if (isVirtual) {
                log(`<br>--- üß™ VIRTUAL SESSION (Wait: ${simState.consecutiveVirtualLosses}/${vLimit}) ---`);
            } else {
                log(`<br>--- üí∞ REAL SESSION ${simState.totalRealSessions + 1} (START) ---`);
            }

            const result = await runSingleSession(isVirtual);
            
            if (isVirtual) {
                if (result.status === "BUST") {
                    simState.consecutiveVirtualLosses++;
                    log(`üìâ Virtual Result: BUST (${simState.consecutiveVirtualLosses}/${vLimit})`);
                } else if (result.status === "WIN") {
                    simState.consecutiveVirtualLosses = 0;
                    log(`üîÑ Virtual Result: WIN (Resetting)`);
                }
            } else {
                simState.totalRealSessions++;
                simState.totalProfit += result.profit;
                if (result.m_bet > simState.overallMaxBet) simState.overallMaxBet = result.m_bet;
                if (result.mdd > simState.overallMaxDrawdown) simState.overallMaxDrawdown = result.mdd;

                if (result.status === "WIN") {
                    log(`‚úÖ REAL WIN: Profit +${result.profit.toFixed(2)}`);
                    simState.totalLossAccumulated = 0;
                    simState.currentTarget = simState.baseTarget;
                    simState.currentBankroll = simState.baseBankroll;
                    simState.currentConsecutiveBusts = 0;
                    simState.consecutiveVirtualLosses = 0;
                } else {
                    log(`‚ùå REAL ${result.status}: Loss ${result.profit.toFixed(2)}`);
                    simState.totalLossAccumulated += Math.abs(result.profit);
                    simState.currentTarget = simState.totalLossAccumulated + simState.baseTarget;
                    simState.currentBankroll = simState.currentTarget * 1.5;
                    simState.currentConsecutiveBusts++;
                    if (simState.currentConsecutiveBusts > simState.maxConsecutiveBusts) simState.maxConsecutiveBusts = simState.currentConsecutiveBusts;
                    log(`‚ö†Ô∏è RECOVERY | Accumulated Loss: ${simState.totalLossAccumulated.toFixed(2)}`);
                }
                updateDashboard();
            }

            if (result.status === "OUT_OF_DATA") break;
        }
        log("<br><b>=== SIMULATION ENDED ===</b>");
    }

    function updateDashboard() {
        document.getElementById('stat_profit').innerText = simState.totalProfit.toFixed(2);
        document.getElementById('stat_max_bet').innerText = simState.overallMaxBet.toLocaleString();
        document.getElementById('stat_mdd').innerText = simState.overallMaxDrawdown.toLocaleString();
        document.getElementById('stat_busts').innerText = simState.maxConsecutiveBusts;
    }

    function resetAll() {
        location.reload();
    }
</script>

</body>
</html>
